{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>Welcome to the PyPythia documentation.</p> <p>Pythia is a lightweight python library to predict the difficulty of Multiple Sequence Alignments (MSA). Phylogenetic analyzes under the Maximum-Likelihood (ML) model are time and resource intensive. To adequately capture the vastness of tree space, one needs to infer multiple independent trees. On some datasets, multiple tree inferences converge to similar tree topologies, on others to multiple, topologically highly distinct yet statistically indistinguishable topologies. Pythia predicts the degree of difficulty of analyzing a dataset prior to initiating ML-based tree inferences. Predicting the difficulty using Pythia is substantially faster than inferring multiple ML trees using RAxML-NG. Pythia can be used to increase user awareness with respect to the amount of signal and uncertainty to be expected in phylogenetic analyzes, and hence inform an appropriate (post-)analysis setup. Further, it can be used to select appropriate search algorithms for easy-, intermediate-, and hard-to-analyze datasets. Pythia supports DNA, AA, and morphological data in Phylip and FASTA format.</p>"},{"location":"#support","title":"Support","text":"<p>If you encounter any trouble using Pythia, have a question, or you find a bug, please feel free to open an issue here.</p>"},{"location":"#publication","title":"Publication","text":"<p>The paper explaining the details of Pythia is published in MBE: Haag, J., H\u00f6hler, D., Bettisworth, B., &amp; Stamatakis, A. (2022). From Easy to Hopeless - Predicting the Difficulty of Phylogenetic Analyses. Molecular Biology and Evolution, 39(12). https://doi.org/10.1093/molbev/msac254</p> <p>Warning</p> <p>Since this publication, we made some considerable changes to Pythia. The most important change is that we switched from using a Random Forest Regressor to using a LightGBM Gradient Boosted Tree Regressor. This affects all Pythia versions &gt;= 1. If you use Pythia in your work, please state the correct learning algorithm. If you are unsure, feel free to reach out to me \ud83d\ude42</p> <p>We will soon publish a pre-print that explains the changes in detail, stay tuned!</p>"},{"location":"#cpythia","title":"CPythia","text":"<p>The same functionality is also available as C library here. Since the C library depends on Coraxlib it is not as easy and fast to use as this python library. If you are only interested in the difficulty of your MSA, we recommend using this Python library. If you want to incorporate the difficulty prediction in a phylogenetic tool, we recommend using the faster C library.</p>"},{"location":"install/","title":"Installing PyPythia","text":""},{"location":"install/#requirements","title":"Requirements","text":"<p>In order to use this difficulty prediction, you need RAxML-NG installed somewhere on your system. You can find the installation instructions here.</p>"},{"location":"install/#install-using-conda-recommended","title":"Install using conda (recommended)","text":"<p>The easiest (and recommended) way to install PyPythia is by using conda:</p> <pre><code>conda install pythiaphylopredictor -c conda-forge -c nodefaults\n</code></pre>"},{"location":"install/#install-using-pip","title":"Install using pip","text":"<p>You can also install Pythia using the python package manager pip:</p> <pre><code>pip install pythiaphylopredictor\n</code></pre> <p>Please note that this can lead to issues with package versions and dependencies when installing in an existing (conda) environment.</p> <p>Verify the correct installation by running <code>pythia -h</code>.</p>"},{"location":"install/#installing-a-specific-tagversion","title":"Installing a specific tag/version","text":"<p>You can again use pip for this and simply specify the tag you wish to install, e.g. for version <code>0.0.1</code> run:</p> <pre><code>pip install git+https://github.com/tschuelia/PyPythia.git@0.0.1\n</code></pre> <p>To install older versions via conda, you need to search for <code>pypythia</code> instead of <code>pythiaphylopredictor</code>.</p>"},{"location":"install/#installation-from-source","title":"Installation from source","text":"<p>You can install Pythia from source if you want to explore the code or get the lastest development version. To do so run the following steps:</p> <pre><code>git clone https://github.com/tschuelia/PyPythia.git\ncd PyPythia\npip install .\n</code></pre> <p>Verify the correct installation by running <code>pythia -h</code>.</p>"},{"location":"install/#troubleshooting","title":"Troubleshooting","text":"<p>Most issues when installing Pythia seem to arise from broken or non-working LightGBM installations. If you encounter any such problem, and none of the following options help, please refer to the LightGBM installation instructions for your operating system and install LightGBM manually before repeating the Pythia installation as described above.</p>"},{"location":"install/#python-version","title":"Python version","text":"<p>Since Pythia version 1.1.0 we provide the option to output the Shapley values for your prediction. Currently, the <code>shap</code> package does not support Python Version 3.11. The requirements should take care of the correct Python version, but if you encounter any issues, please first check that the Python version is &lt;3.11. You can do so by typing <code>python --version</code> in your terminal and checking the output.</p>"},{"location":"install/#installing-on-m1-chips","title":"Installing on M1 chips","text":"<p>Installing on MacBooks with M1 chips caused some trouble for some users that seem to be caused by LightGBM's multiprocessing support. If you encounter any errors with the log pointing to LightGBM, the first thing you could try is to install LightGBM using homebrew:</p> <pre><code>brew install lightgbm\n</code></pre> <p>This might take a few minutes to finish. Once this ran successfully you can try to rerun the install instructions above.</p> <p>If this does not solve your problem, you can try to install LightGBM manually using pip and disabling the multiprocessing:</p> <pre><code>pip install lightgbm --install-option=--nomp\n</code></pre> <p>and then rerun the installation of PyPythia. Thanks @willbour for finding the fix for this!</p>"},{"location":"install/#using-a-clean-conda-environment","title":"Using a clean conda environment","text":"<p>When using conda and installing PyPythia using pip in an existing environment, you might encounter dependency or version related issues. To check whether this is the case or you have a general issue with Pythia please try to create a new, clean conda environment:</p> <ol> <li>Use the provided environment file <code>etc/environment.yml</code> and create a new conda environment:</li> </ol> <pre><code>conda env create --file etc/environment.yml\n</code></pre> <p>If you want to install a different version of Pythia, you can add the git tag by appending <code>@[version]</code> (e.g. for version 1.1.0 append <code>@1.1.0</code>) after <code>.git</code> in the <code>etc/environment.yml</code> file.</p> <ol> <li>Activate the conda environment: <code>conda activate pythia</code></li> <li>Try to (re)run Pythia.</li> </ol>"},{"location":"install/#running-pythia","title":"Running Pythia","text":"<p>If you are having trouble running pythia, you can also replace <code>pythia</code> with <code>python pypythia/main.py</code>. For this to work you need to install Pythia from source and you need to be in the PyPythia directory (which you should be after the installation).</p>"},{"location":"usage/","title":"Using PyPythia","text":"<p>This library can be used in two ways: either directly as command line tool, or the prediction can be called from other python code.</p>"},{"location":"usage/#command-line-interface","title":"Command Line Interface","text":"<p>If you only want to predict the difficulty for a single MSA, you can query the predictor using the command line interface, for example like this:</p> <pre><code>pythia --msa examples/example.phy --raxmlng /path/to/raxml-ng\n</code></pre> <p>Note that when you installed PyPythia using conda, you will have to download the <code>example.phy</code> and adjust the path accordingly.</p> <p>The output will be something like <code>The predicted difficulty for MSA examples/example.phy is: 0.02.</code>, telling us that example.phy is an easy dataset. In fact, this dataset exhibits a single likelihood peak. Depending on the predictor version or operating system you are using, the actual value might slightly differ. This is expected and nothing to worry about \ud83d\ude42</p> <p>Note that Pythia can also handle FASTA input files, see section Input Data below.</p> <p>The following options are available:</p> <pre><code>PyPythia version 2.0.0 released by The Exelixis Lab\nDeveloped by: Julia Haag\nLatest version: https://github.com/tschuelia/PyPythia\nQuestions/problems/suggestions? Please open an issue on GitHub.\n\nusage: pythia [-h] -m MSA -r RAXMLNG [-t THREADS] [-s SEED] [-p PREFIX]\n              [--predictor PREDICTOR] [--shap] [--forceDuplicates] [--forceFullGaps]\n              [--nofiles] [-V]\n\nParser for Pythia command line options.\n\noptions:\n  -h, --help            show this help message and exit\n  -m MSA, --msa MSA     Multiple Sequence Alignment to predict the difficulty for. Must be\n                        in either phylip or fasta format.\n  -r RAXMLNG, --raxmlng RAXMLNG\n                        Path to the binary of RAxML-NG. For install instructions see\n                        https://github.com/amkozlov/raxml-ng.(default: 'raxml-ng' if in\n                        $PATH, otherwise this option is mandatory).\n  -t THREADS, --threads THREADS\n                        Number of threads to use for parallel parsimony tree inference\n                        (default: RAxML-NG autoconfig).\n  -s SEED, --seed SEED  Seed for the RAxML-NG parsimony tree inference (default: 0).\n  -p PREFIX, --prefix PREFIX\n                        Prefix of the PyPythia log and result file (default: MSA file name).\n  --predictor PREDICTOR\n                        Filepath of the alternative predictor to use (default: latest\n                        Pythia).\n  --shap                If set, computes the shapley values of the prediction as waterfall\n                        plot in '{prefix}.shap.pdf'. When using this option, make sure you\n                        understand what shapley values are and how to interpret this\n                        plot.For details on shapley values refer to the documentation:\n                        https://tschuelia.github.io/PyPythia/latest/usage/#shap-waterfall-\n                        plot (default: False).\n  --forceDuplicates     Per default, Pythia refuses to predict the difficulty for MSAs\n                        containing duplicate sequences,and removes duplicate sequences prior\n                        to predicting the difficulty. Only set this option if you are\n                        absolutely sure that you want to predict the difficulty for this MSA\n                        (default: False).\n  --forceFullGaps       Per default, Pythia refuses to predict the difficulty for MSAs\n                        containing sequences with only gaps,and removes full-gap sequences\n                        prior to predicting the difficulty. Only set this option if you are\n                        absolutely sure that you want to predict the difficulty for this MSA\n                        (default: False).\n  --nofiles             Prevent Pythia from writing any files and only print logs/results to\n                        the terminal (default: False). WARNING: in this case and if your MSA\n                        contains duplicate/full-gap sequences the reduced MSA will not be\n                        stored.\n  -V, --version         Print the version number and exit.\n</code></pre>"},{"location":"usage/#result-files","title":"Result files","text":"<p>Pythia will write the following files: - A logfile containing the same information as printed to the terminal: <code>{result_prefix}.pythia.log</code> - The reduced MSA file in case the input MSA contained duplicate/full-gap sequences (and the reduction was not disabled): <code>{result_prefix}.reduced.phy</code> - The inferred parsimony trees in Newick format: <code>{result_prefix}.pythia.trees</code> - The shapley values as waterfall plot (if --shap is set): <code>{result_prefix}.shap.pdf</code> - The features and predicted difficulty as CSV file: <code>{result_prefix}.pythia.csv</code></p> <p>The result_prefix can be set using the <code>--prefix</code> command line option. If not set, Pythia uses the MSA file as prefix. You can prevent Pythia from writing any files via the flag <code>--nofiles</code>.</p>"},{"location":"usage/#from-code","title":"From Code","text":"<p>You can also use the library as a regular python library by installing it in your current environment. The following code snippet shows how to predict the difficulty for an MSA using PyPythia:</p> <pre><code>from pypythia.prediction import predict_difficulty\nimport pathlib\n\nmsa = pathlib.Path(\"examples/example.phy\")\ndifficulty = predict_difficulty(msa)\nprint(f\"The predicted difficulty for MSA {msa} is: {round(difficulty, 2)}.\")\n</code></pre> <p>And the output will be the same as for the CLI: <code>The predicted difficulty for MSA examples/example.phy is: 0.02.</code>.</p> <p>If you want to get all features, or do more specific analyses of your MSA, see the API Reference for further details on all available classes and methods.</p>"},{"location":"usage/#input-data","title":"Input data","text":""},{"location":"usage/#supported-file-types","title":"Supported file types","text":"<p>The input for Pythia is an MSA file in either Phylip or FASTA format.</p>"},{"location":"usage/#supported-data-types","title":"Supported  data types","text":"<p>Pythia supports DNA, AA, and morphological data.</p> <p>Please note that by morphological data we refer to biological data. According to our analyses, the attributes of biological morphological data are similar to the attributes of DNA and AA data. However, when analyzing language data (cognate, sound-class, and morphosyntactic data) we observed substantially distinct attributes and concluded that morphological language data is not comparable to DNA, AA, or biological morphological data. Thus, at the moment Pythia is not able to reliably predict the difficulty for language alignments.</p>"},{"location":"usage/#taxon-names","title":"Taxon names","text":"<p>Make sure that the MSA only contains RAxML-NG compatible taxon names. In particular, taxon labels with spaces, tabs, newlines, commas, colons, semicolons and parenthesis are invalid.</p>"},{"location":"usage/#msas-with-duplicate-sequences","title":"MSAs with duplicate sequences","text":"<p>Pythia refuses to predict the difficulty for MSAs containing duplicate sequences or MSAs containing sequences containing only gaps. As of version 2.0.0, Pythia removes duplicates and full-gap sequences per default and predicts the difficulty for this reduced MSA. If you absolutely want to predict the difficulty for the original MSA, set the command line flags <code>--forceDuplicates</code> and <code>--forceFullGaps</code>.</p> <p>As of version 1.0.0 Pythia refuses to predict the difficulty for MSAs containing multiple exactly identical sequences ( duplicate sequences). The reason for this is that duplicate sequences can have a substantial impact on the resulting topologies during the maximum parsimony tree inference and therefore on the topological distance measures.</p> <p>If you set the command line option <code>--removeDuplicates</code>, Pythia will create a reduced alignment with all duplicates removed and predict the difficulty for this reduced alignment. For duplicate sequences, the first occurrence of the sequence is kept. WARNING: The resulting predicted difficulty is only applicable to the reduced MSA! We recommend to only use the created reduced alignment for your subsequent analyses.</p>"},{"location":"usage/#predictors","title":"Predictors","text":"<p>To continuously and automatically improve the prediction accuracy of Pythia, we regularly extend the training data set and subsequently retrain the predictor. We extend the training data using the anonymized MSAs that we continuously obtain during our RAxML Grove database updates. Note that these MSAs are only available internally in RAxML Grove and are not publicly available. As per default, PyPythia uses the latest predictor <code>predictors/latest.txt</code>. If you want to use an older version of Pythia, please install the respective PyPythia version. You can also pass a custom predictor file using the <code>--predictor</code> option. However, this will only work if the passed file contains a LightGBM Booster model.</p> <p>Note that the predictions for the same MSA can be different when using different versions of Pythia.</p>"},{"location":"usage/#shap-waterfall-plot","title":"SHAP Waterfall Plot","text":"<p>As of version 1.1.0, Pythia includes an option to plot Shapley values for a prediction. The interpretation of Shapley values is not straight-forward, and we emphasize the importance of learning about these values before drawing conclusions based on the resulting plot! We provide the Shapley values as waterfall plot. In the following, we briefly describe what Shapley values are, what a waterfall plot is, and how you can interpret this plot. It is important to note that Shapley values are not the same as feature importances. Predicting the difficulty of two distinct MSAs will lead to two distinct waterfall plots.</p>"},{"location":"usage/#shapley-values","title":"Shapley Values","text":"<p>Based on the training data, our difficulty predictor Pythia has learned a base line difficulty. This base line difficulty is the expected value for every new prediction. Starting off this base line, Pythia adjusts its prediction using the features of the MSA. To determine how much each feature contributes to this change, ultimately leading to the final prediction is estimated by Shapley values. Since Pythia is a tree-based regressor, computing the Shapley values requires some advanced mathematics that I won't go into detail about here. If you are interested in this check out the links in the More Details section below. Due to the calculation of Shapley values, the value for one feature is NOT the difference in prediction when removing this feature. The Shapley value for one feature can only be interpreted considering all feature values together for a specific set of feature values.</p>"},{"location":"usage/#waterfall-plot","title":"Waterfall plot","text":"<p>The following figure shows an exemplary waterfall plot output for the MSA <code>example/example.py</code> and Pythia version 1.1.0.</p> <p>The x-axis depicts the difficulty and the y-axis the features alongside the respective feature value. The features are sorted by their Shapley value with the most important feature on top. You can read the plot as follows. The baseline difficulty that Pythia v1.1.0 learned is 0.35, as indicated by the <code>E[f(x)] = 0.35</code> on the x-axis. The <code>proportion_invariant</code> feature contributed to the overall prediction with a shift towards <code>1.0</code> (more difficult) of <code>0.01</code>, so in combination with the other features, a <code>proportion_invariant</code> of <code>0.341</code> indicates that the MSA is slightly more difficult than the average difficulty in the training set. We emphasize that the combination with the other features part, since the same value for <code>proportion_invariant</code> with a different MSA and different feature values for the remaining features might lead to a substantially different contribution to the overall prediction. The feature with the highest impact for this example is the patterns-over-taxa ratio (<code>num_patterns/num_taxa</code>). The overall contribution is 0.23 towards <code>0.0</code>, meaning it shifts the overall prediction towards <code>easy</code>.</p> <p></p>"},{"location":"usage/#more-details","title":"More Details","text":"<p>For further information please refer to this great book on interpretable ML, the documentation of the <code>shap</code> package, especially their notes on the interpretability of Shapley values.</p>"},{"location":"api/config/","title":"config","text":""},{"location":"api/config/#pypythia.config.DEFAULT_MODEL_FILE","title":"<code>pypythia.config.DEFAULT_MODEL_FILE = pathlib.Path(__file__).parent / 'predictors' / 'latest.txt'</code>  <code>module-attribute</code>","text":""},{"location":"api/config/#pypythia.config.DEFAULT_RAXMLNG_EXE","title":"<code>pypythia.config.DEFAULT_RAXMLNG_EXE = pathlib.Path(shutil.which('raxml-ng')) if shutil.which('raxml-ng') else None</code>  <code>module-attribute</code>","text":""},{"location":"api/custom_errors/","title":"custom_errors","text":""},{"location":"api/custom_errors/#pypythia.custom_errors.PyPythiaException","title":"<code>pypythia.custom_errors.PyPythiaException</code>","text":"<p>               Bases: <code>Exception</code></p> Source code in <code>pypythia/custom_errors.py</code> <pre><code>class PyPythiaException(Exception):\n    pass\n</code></pre>"},{"location":"api/custom_errors/#pypythia.custom_errors.RAxMLNGError","title":"<code>pypythia.custom_errors.RAxMLNGError</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Custom RAxML-NG Exception used when running RAxML-NG commands. In case of a subprocess.CalledProcessError, the output of this Exception is either the entire RAxML-NG output, or only the lines containing the cause for the RAxML-NG error if the RAxML-NG output contains lines starting with \"ERROR\"</p> Source code in <code>pypythia/custom_errors.py</code> <pre><code>class RAxMLNGError(Exception):\n    \"\"\"\n    Custom RAxML-NG Exception used when running RAxML-NG commands.\n    In case of a subprocess.CalledProcessError, the output of this Exception is either the entire RAxML-NG output,\n    or only the lines containing the cause for the RAxML-NG error if the RAxML-NG output contains\n    lines starting with \"ERROR\"\n    \"\"\"\n\n    def __init__(self, subprocess_exception: subprocess.CalledProcessError):\n        error_information = []\n\n        for line in subprocess_exception.output.split(\"\\n\"):\n            if line.strip().startswith(\"ERROR\"):\n                error_information.append(line.strip())\n\n        if len(error_information) &gt; 0:\n            error_details = \"RAxML-NG exited with the following error:\\n\"\n            error_details += \"\\t\" + \"\\n\\t\".join(error_information)\n        else:\n            error_details = \"check the following RAxML-NG log for further information on the error(s):\\n\"\n            error_details += subprocess_exception.output\n\n        cmd = \" \".join(subprocess_exception.cmd)\n        self.message = f\"Running RAxML-NG command failed: {cmd}\\n\" + error_details\n        super().__init__(self.message)\n</code></pre>"},{"location":"api/custom_types/","title":"custom_types","text":""},{"location":"api/custom_types/#pypythia.custom_types.DataType","title":"<code>pypythia.custom_types.DataType</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Data type for MSAs. - DNA = DNA data - AA = Protein data - MORPH = morphological data</p> Source code in <code>pypythia/custom_types.py</code> <pre><code>class DataType(Enum):\n    \"\"\"Data type for MSAs.\n    - DNA = DNA data\n    - AA = Protein data\n    - MORPH = morphological data\n    \"\"\"\n\n    DNA = \"DNA\"\n    AA = \"AA\"\n    MORPH = \"MORPH\"\n</code></pre>"},{"location":"api/custom_types/#pypythia.custom_types.FileFormat","title":"<code>pypythia.custom_types.FileFormat</code>","text":"<p>               Bases: <code>Enum</code></p> <p>File formats for MSAs - PHYLIP = phylip-relaxed - FASTA = fasta</p> Source code in <code>pypythia/custom_types.py</code> <pre><code>class FileFormat(Enum):\n    \"\"\"File formats for MSAs\n    - PHYLIP = phylip-relaxed\n    - FASTA = fasta\n    \"\"\"\n\n    PHYLIP = \"phylip-relaxed\"\n    FASTA = \"fasta\"\n</code></pre>"},{"location":"api/msa/","title":"msa","text":""},{"location":"api/msa/#pypythia.msa.MSA","title":"<code>pypythia.msa.MSA</code>","text":"<p>Multiple Sequence Alignment class</p> <p>Parameters:</p> Name Type Description Default <code>taxa</code> <code>NDArray</code> <p>Array of taxa names</p> required <code>sequences</code> <code>NDArray</code> <p>The data matrix containing the sequence data. The order of the rows corresponds to the order of the taxa in the taxa array. The data is stored as a 2D numpy array of bytes using the S1 numpy data type.</p> required <code>data_type</code> <code>DataType</code> <p>Data type of the sequences</p> required <code>name</code> <code>str</code> <p>Name of the MSA</p> required <p>Attributes:</p> Name Type Description <code>taxa</code> <code>NDArray</code> <p>Array of taxa names</p> <code>sequences</code> <code>NDArray</code> <p>The data matrix containing the sequence data. The order of the rows corresponds to the order of the taxa in the taxa array. The data is stored as a 2D numpy array of bytes using the S1 numpy data type.</p> <code>data_type</code> <code>DataType</code> <p>Data type of the sequences</p> <code>name</code> <code>str</code> <p>Name of the MSA</p> <code>n_taxa</code> <code>int</code> <p>Number of taxa</p> <code>n_sites</code> <code>int</code> <p>Number of sites</p> <p>Raises:</p> Type Description <code>PyPythiaException</code> <p>If the number of taxa in <code>taxa</code> and the number of sequences in <code>sequences</code> do not match.</p> Source code in <code>pypythia/msa.py</code> <pre><code>class MSA:\n    \"\"\"Multiple Sequence Alignment class\n\n    Args:\n        taxa (npt.NDArray): Array of taxa names\n        sequences (npt.NDArray): The data matrix containing the sequence data.\n            The order of the rows corresponds to the order of the taxa in the taxa array.\n            The data is stored as a 2D numpy array of bytes using the S1 numpy data type.\n        data_type (DataType): Data type of the sequences\n        name (str): Name of the MSA\n\n    Attributes:\n        taxa (npt.NDArray): Array of taxa names\n        sequences (npt.NDArray): The data matrix containing the sequence data.\n            The order of the rows corresponds to the order of the taxa in the taxa array.\n            The data is stored as a 2D numpy array of bytes using the S1 numpy data type.\n        data_type (DataType): Data type of the sequences\n        name (str): Name of the MSA\n        n_taxa (int): Number of taxa\n        n_sites (int): Number of sites\n\n    Raises:\n        PyPythiaException: If the number of taxa in `taxa` and the number of sequences in `sequences` do not match.\n\n    \"\"\"\n\n    def __init__(\n        self, taxa: npt.NDArray, sequences: npt.NDArray, data_type: DataType, name: str\n    ):\n        if taxa.shape[0] != sequences.shape[0]:\n            raise PyPythiaException(\n                \"Number of taxa and sequences do not match: \"\n                f\"{taxa.shape[0]} != {sequences.shape[0]}.\"\n            )\n\n        self.taxa = taxa\n        self.sequences = sequences\n        self.data_type = data_type\n        self.name = name\n\n        self.n_taxa, self.n_sites = self.sequences.shape\n\n    def __str__(self):\n        return f\"MSA(name={self.name}, n_taxa={self.n_taxa}, n_sites={self.n_sites}, data_type={self.data_type.name})\"\n\n    def __repr__(self):\n        return str(self)\n\n    def contains_full_gap_sequences(self) -&gt; bool:\n        \"\"\"Check if the MSA contains full-gap sequences.\n\n        A full-gap sequence is a sequence where all sites are gaps so the sequence does not contain any information.\n\n        Returns:\n            True if full-gap sequences are present, False otherwise.\n        \"\"\"\n        return np.any(np.all(self.sequences == GAP, axis=1))\n\n    def contains_duplicate_sequences(self) -&gt; bool:\n        \"\"\"Check if the MSA contains duplicate sequences.\n\n        Returns:\n            True if duplicate sequences are present, False otherwise.\n        \"\"\"\n        unique_sequences = np.unique(self.sequences, axis=0)\n        return unique_sequences.shape[0] &lt; self.sequences.shape[0]\n\n    @cached_property\n    def n_patterns(self) -&gt; int:\n        \"\"\"Returns the number of unique patterns in the MSA.\n\n        A pattern is a unique combination of characters at a site in the MSA.\n        A full-gap site is not considered a pattern.\n\n        Returns:\n            Number of unique patterns\n        \"\"\"\n        un = set([c.tobytes() for c in self.sequences.T])\n        return len(un) - ((GAP * self.n_taxa) in un)\n\n    @cached_property\n    def proportion_gaps(self) -&gt; float:\n        \"\"\"Returns the proportion of gap characters in the MSA.\n        Note that prior to calculating the percentage, full-gap sites are removed.\n\n        Returns:\n            Proportion of gap characters in the MSA\n        \"\"\"\n        full_gap_sites_removed = self.sequences[\n            :, ~np.all(self.sequences.T == GAP, axis=1)\n        ]\n        return np.sum(full_gap_sites_removed == GAP) / full_gap_sites_removed.size\n\n    @cached_property\n    def proportion_invariant(self) -&gt; float:\n        \"\"\"Returns the proportion of invariant sites in the MSA.\n        A site is considered invariant if all sequences have the same character at that site.\n        Full-gap sites are not counted as invariant.\n        A site is also counted as invariant, if there is a possible assignment of ambiguous characters such that the\n        site is invariant.\n        For example, the DNA site `AAAMA` is considered invariant because it can be resolved to `AAAAA`.\n\n        Returns:\n            Proportion of invariant sites in the MSA\n\n        \"\"\"\n        if self.data_type == DataType.DNA:\n            charmap = DNA_AMBIGUITY_MAP\n        elif self.data_type == DataType.AA:\n            charmap = AA_AMBIGUITY_MAP\n        else:\n            charmap = {}\n\n        non_gap_site_count = 0\n        invariant_count = 0\n\n        gap_ord_set = {GAP_ORD}\n\n        for site in self.sequences.T:\n            site = set(site.tobytes())\n            if site == gap_ord_set:\n                # full-gap sites are not counted as invariant\n                continue\n\n            non_gap_site_count += 1\n\n            for allowed in charmap.values():\n                if site.issubset(allowed):\n                    invariant_count += 1\n                    break\n\n        return invariant_count / non_gap_site_count\n\n    def entropy(self) -&gt; float:\n        \"\"\"Returns the entropy of the MSA.\n\n        The entropy is calculated as the mean entropy of all sites in the MSA.\n        and the site-entropy is calculated as the Shannon entropy of the site.\n\n        Returns:\n            Entropy of the MSA.\n        \"\"\"\n\n        def _site_entropy(site):\n            site_counter = Counter(site.tobytes())\n            site_counter.pop(GAP_ORD, None)\n\n            counts = np.array(list(site_counter.values()))\n            probabilities = counts / np.sum(counts)\n            return -np.sum(probabilities * np.log2(probabilities))\n\n        return np.mean([_site_entropy(site) for site in self.sequences.T])\n\n    def pattern_entropy(self) -&gt; float:\n        r\"\"\"Returns an entropy-like metric based on the number of occurrences of all patterns of the MSA.\n\n        The pattern entropy is calculated as\n        $$\n        \\sum_{i=1}^{p} N_i \\log(N_i)\n        $$\n        with $N_i$ being the number of occurrences of pattern $i$ and $p$ being the number of unique patterns in the MSA.\n\n        Returns:\n            Entropy-like metric based on the number of occurrences of all patterns of the MSA.\n        \"\"\"\n        patterns = [c.tobytes() for c in self.sequences.T]\n        pattern_counter = Counter(patterns)\n        pattern_counts = np.array(list(pattern_counter.values()))\n        return np.sum(pattern_counts * np.log(pattern_counts))\n\n    def bollback_multinomial(self) -&gt; float:\n        r\"\"\"\n        Returns the Bollback multinomial metric for the MSA.\n\n        The Bollback multinomial metric is calculated as\n        $$\n        \\sum_{i=1}^{p} N_i \\log(N_i) - n \\log(n)\n        $$\n        with $N_i$ being the number of occurrences of pattern $i$,\n        $p$ being the number of unique patterns in the MSA, and $n$ being the number of sites in the MSA.\n\n        Returns:\n            Bollback multinomial metric for the MSA.\n        \"\"\"\n        pattern_entropy = self.pattern_entropy()\n        return pattern_entropy - self.n_sites * math.log(self.n_sites)\n\n    def get_raxmlng_model(self) -&gt; str:\n        \"\"\"Returns a RAxML-NG model string based on the data type.\n\n        Returns the following models:\n            * For DNA data: GTR+G\n            * For Protein (AA) data: LG+G\n            * For morphological data: MULTIx_GTR where x refers to the maximum state value in the alignment\n\n        Returns:\n             RAxML-NG model string\n        \"\"\"\n        if self.data_type == DataType.DNA:\n            return \"GTR+G\"\n        elif self.data_type == DataType.AA:\n            return \"LG+G\"\n        elif self.data_type == DataType.MORPH:\n            unique = np.unique(self.sequences)\n            # the number of unique states is irrelevant for RAxML-NG, it only cares about the max state value...\n            num_states = int(max(unique)) + 1\n            return f\"MULTI{num_states}_GTR\"\n        else:\n            raise PyPythiaException(\"Unsupported data type: \", self.data_type)\n\n    def write(\n        self, output_file: pathlib.Path, file_format: FileFormat = FileFormat.PHYLIP\n    ):\n        \"\"\"Write the MSA to a file.\n\n        Args:\n            output_file (pathlib.Path): Path to the output file\n            file_format (FileFormat): File format to use for writing the MSA. Defaults to FileFormat.PHYLIP\n        \"\"\"\n        _biopython_sequences = [\n            SeqRecord(Seq(seq.tobytes()), id=taxon)\n            for seq, taxon in zip(self.sequences, self.taxa)\n        ]\n        SeqIO.write(_biopython_sequences, output_file, file_format.value)\n</code></pre>"},{"location":"api/msa/#pypythia.msa.MSA.n_patterns","title":"<code>n_patterns</code>  <code>cached</code> <code>property</code>","text":"<p>Returns the number of unique patterns in the MSA.</p> <p>A pattern is a unique combination of characters at a site in the MSA. A full-gap site is not considered a pattern.</p> <p>Returns:</p> Type Description <code>int</code> <p>Number of unique patterns</p>"},{"location":"api/msa/#pypythia.msa.MSA.proportion_gaps","title":"<code>proportion_gaps</code>  <code>cached</code> <code>property</code>","text":"<p>Returns the proportion of gap characters in the MSA. Note that prior to calculating the percentage, full-gap sites are removed.</p> <p>Returns:</p> Type Description <code>float</code> <p>Proportion of gap characters in the MSA</p>"},{"location":"api/msa/#pypythia.msa.MSA.proportion_invariant","title":"<code>proportion_invariant</code>  <code>cached</code> <code>property</code>","text":"<p>Returns the proportion of invariant sites in the MSA. A site is considered invariant if all sequences have the same character at that site. Full-gap sites are not counted as invariant. A site is also counted as invariant, if there is a possible assignment of ambiguous characters such that the site is invariant. For example, the DNA site <code>AAAMA</code> is considered invariant because it can be resolved to <code>AAAAA</code>.</p> <p>Returns:</p> Type Description <code>float</code> <p>Proportion of invariant sites in the MSA</p>"},{"location":"api/msa/#pypythia.msa.MSA.bollback_multinomial","title":"<code>bollback_multinomial()</code>","text":"<p>Returns the Bollback multinomial metric for the MSA.</p> <p>The Bollback multinomial metric is calculated as $$ \\sum_{i=1}^{p} N_i \\log(N_i) - n \\log(n) $$ with \\(N_i\\) being the number of occurrences of pattern \\(i\\), \\(p\\) being the number of unique patterns in the MSA, and \\(n\\) being the number of sites in the MSA.</p> <p>Returns:</p> Type Description <code>float</code> <p>Bollback multinomial metric for the MSA.</p> Source code in <code>pypythia/msa.py</code> <pre><code>def bollback_multinomial(self) -&gt; float:\n    r\"\"\"\n    Returns the Bollback multinomial metric for the MSA.\n\n    The Bollback multinomial metric is calculated as\n    $$\n    \\sum_{i=1}^{p} N_i \\log(N_i) - n \\log(n)\n    $$\n    with $N_i$ being the number of occurrences of pattern $i$,\n    $p$ being the number of unique patterns in the MSA, and $n$ being the number of sites in the MSA.\n\n    Returns:\n        Bollback multinomial metric for the MSA.\n    \"\"\"\n    pattern_entropy = self.pattern_entropy()\n    return pattern_entropy - self.n_sites * math.log(self.n_sites)\n</code></pre>"},{"location":"api/msa/#pypythia.msa.MSA.contains_duplicate_sequences","title":"<code>contains_duplicate_sequences()</code>","text":"<p>Check if the MSA contains duplicate sequences.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if duplicate sequences are present, False otherwise.</p> Source code in <code>pypythia/msa.py</code> <pre><code>def contains_duplicate_sequences(self) -&gt; bool:\n    \"\"\"Check if the MSA contains duplicate sequences.\n\n    Returns:\n        True if duplicate sequences are present, False otherwise.\n    \"\"\"\n    unique_sequences = np.unique(self.sequences, axis=0)\n    return unique_sequences.shape[0] &lt; self.sequences.shape[0]\n</code></pre>"},{"location":"api/msa/#pypythia.msa.MSA.contains_full_gap_sequences","title":"<code>contains_full_gap_sequences()</code>","text":"<p>Check if the MSA contains full-gap sequences.</p> <p>A full-gap sequence is a sequence where all sites are gaps so the sequence does not contain any information.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if full-gap sequences are present, False otherwise.</p> Source code in <code>pypythia/msa.py</code> <pre><code>def contains_full_gap_sequences(self) -&gt; bool:\n    \"\"\"Check if the MSA contains full-gap sequences.\n\n    A full-gap sequence is a sequence where all sites are gaps so the sequence does not contain any information.\n\n    Returns:\n        True if full-gap sequences are present, False otherwise.\n    \"\"\"\n    return np.any(np.all(self.sequences == GAP, axis=1))\n</code></pre>"},{"location":"api/msa/#pypythia.msa.MSA.entropy","title":"<code>entropy()</code>","text":"<p>Returns the entropy of the MSA.</p> <p>The entropy is calculated as the mean entropy of all sites in the MSA. and the site-entropy is calculated as the Shannon entropy of the site.</p> <p>Returns:</p> Type Description <code>float</code> <p>Entropy of the MSA.</p> Source code in <code>pypythia/msa.py</code> <pre><code>def entropy(self) -&gt; float:\n    \"\"\"Returns the entropy of the MSA.\n\n    The entropy is calculated as the mean entropy of all sites in the MSA.\n    and the site-entropy is calculated as the Shannon entropy of the site.\n\n    Returns:\n        Entropy of the MSA.\n    \"\"\"\n\n    def _site_entropy(site):\n        site_counter = Counter(site.tobytes())\n        site_counter.pop(GAP_ORD, None)\n\n        counts = np.array(list(site_counter.values()))\n        probabilities = counts / np.sum(counts)\n        return -np.sum(probabilities * np.log2(probabilities))\n\n    return np.mean([_site_entropy(site) for site in self.sequences.T])\n</code></pre>"},{"location":"api/msa/#pypythia.msa.MSA.get_raxmlng_model","title":"<code>get_raxmlng_model()</code>","text":"<p>Returns a RAxML-NG model string based on the data type.</p> Returns the following models <ul> <li>For DNA data: GTR+G</li> <li>For Protein (AA) data: LG+G</li> <li>For morphological data: MULTIx_GTR where x refers to the maximum state value in the alignment</li> </ul> <p>Returns:</p> Type Description <code>str</code> <p>RAxML-NG model string</p> Source code in <code>pypythia/msa.py</code> <pre><code>def get_raxmlng_model(self) -&gt; str:\n    \"\"\"Returns a RAxML-NG model string based on the data type.\n\n    Returns the following models:\n        * For DNA data: GTR+G\n        * For Protein (AA) data: LG+G\n        * For morphological data: MULTIx_GTR where x refers to the maximum state value in the alignment\n\n    Returns:\n         RAxML-NG model string\n    \"\"\"\n    if self.data_type == DataType.DNA:\n        return \"GTR+G\"\n    elif self.data_type == DataType.AA:\n        return \"LG+G\"\n    elif self.data_type == DataType.MORPH:\n        unique = np.unique(self.sequences)\n        # the number of unique states is irrelevant for RAxML-NG, it only cares about the max state value...\n        num_states = int(max(unique)) + 1\n        return f\"MULTI{num_states}_GTR\"\n    else:\n        raise PyPythiaException(\"Unsupported data type: \", self.data_type)\n</code></pre>"},{"location":"api/msa/#pypythia.msa.MSA.pattern_entropy","title":"<code>pattern_entropy()</code>","text":"<p>Returns an entropy-like metric based on the number of occurrences of all patterns of the MSA.</p> <p>The pattern entropy is calculated as $$ \\sum_{i=1}^{p} N_i \\log(N_i) $$ with \\(N_i\\) being the number of occurrences of pattern \\(i\\) and \\(p\\) being the number of unique patterns in the MSA.</p> <p>Returns:</p> Type Description <code>float</code> <p>Entropy-like metric based on the number of occurrences of all patterns of the MSA.</p> Source code in <code>pypythia/msa.py</code> <pre><code>def pattern_entropy(self) -&gt; float:\n    r\"\"\"Returns an entropy-like metric based on the number of occurrences of all patterns of the MSA.\n\n    The pattern entropy is calculated as\n    $$\n    \\sum_{i=1}^{p} N_i \\log(N_i)\n    $$\n    with $N_i$ being the number of occurrences of pattern $i$ and $p$ being the number of unique patterns in the MSA.\n\n    Returns:\n        Entropy-like metric based on the number of occurrences of all patterns of the MSA.\n    \"\"\"\n    patterns = [c.tobytes() for c in self.sequences.T]\n    pattern_counter = Counter(patterns)\n    pattern_counts = np.array(list(pattern_counter.values()))\n    return np.sum(pattern_counts * np.log(pattern_counts))\n</code></pre>"},{"location":"api/msa/#pypythia.msa.MSA.write","title":"<code>write(output_file, file_format=FileFormat.PHYLIP)</code>","text":"<p>Write the MSA to a file.</p> <p>Parameters:</p> Name Type Description Default <code>output_file</code> <code>Path</code> <p>Path to the output file</p> required <code>file_format</code> <code>FileFormat</code> <p>File format to use for writing the MSA. Defaults to FileFormat.PHYLIP</p> <code>PHYLIP</code> Source code in <code>pypythia/msa.py</code> <pre><code>def write(\n    self, output_file: pathlib.Path, file_format: FileFormat = FileFormat.PHYLIP\n):\n    \"\"\"Write the MSA to a file.\n\n    Args:\n        output_file (pathlib.Path): Path to the output file\n        file_format (FileFormat): File format to use for writing the MSA. Defaults to FileFormat.PHYLIP\n    \"\"\"\n    _biopython_sequences = [\n        SeqRecord(Seq(seq.tobytes()), id=taxon)\n        for seq, taxon in zip(self.sequences, self.taxa)\n    ]\n    SeqIO.write(_biopython_sequences, output_file, file_format.value)\n</code></pre>"},{"location":"api/msa/#pypythia.msa.parse_msa","title":"<code>pypythia.msa.parse_msa(msa_file, file_format=None, data_type=None)</code>","text":"<p>Parse a multiple sequence alignment file. Note that the file needs to be in FASTA or PHYLIP format.</p> <p>Per default, the file format and data type are inferred from the file content. If the file format cannot be determined, a PyPythiaException is raised. In this case, make sure the file is in proper FASTA or PHYLIP format. If you are absolutely sure it is, you can provide the file format manually.</p> <p>Similarly, if the data type cannot be inferred, a PyPythiaException is raised including information about the characters that could not be assigned to a data type. In this case, you can provide the data type manually. Note that we check for the data type in the following order: DNA -&gt; AA -&gt; MORPH. In case your MSA contains AA data, but coincidentally only contains characters that are nucleotides or ambiguous DNA characters, the data is assumed to be DNA. In this case, please provide the correct data type (<code>DataType.AA</code>) manually.</p> <p>Parameters:</p> Name Type Description Default <code>msa_file</code> <code>Path</code> <p>Path to the MSA file</p> required <code>file_format</code> <code>FileFormat</code> <p>File format of the MSA file. Defaults to None. In this case, the file format is determined automatically.</p> <code>None</code> <code>data_type</code> <code>DataType</code> <p>Data type of the sequences. Defaults to None. In this case, the data type is inferred from the sequences.</p> <code>None</code> <p>Returns:</p> Type Description <code>MSA</code> <p>The parsed MSA object.</p> Source code in <code>pypythia/msa.py</code> <pre><code>def parse_msa(\n    msa_file: pathlib.Path,\n    file_format: Optional[FileFormat] = None,\n    data_type: Optional[DataType] = None,\n) -&gt; MSA:\n    \"\"\"Parse a multiple sequence alignment file. Note that the file needs to be in FASTA or PHYLIP format.\n\n    Per default, the file format and data type are inferred from the file content.\n    If the file format cannot be determined, a PyPythiaException is raised. In this case, make sure the file is in\n    proper FASTA or PHYLIP format. If you are absolutely sure it is, you can provide the file format manually.\n\n    Similarly, if the data type cannot be inferred, a PyPythiaException is raised including information about the\n    characters that could not be assigned to a data type. In this case, you can provide the data type manually.\n    Note that we check for the data type in the following order: DNA -&gt; AA -&gt; MORPH. In case your MSA contains AA data,\n    but coincidentally only contains characters that are nucleotides or ambiguous DNA characters, the data is assumed\n    to be DNA. In this case, please provide the correct data type (`DataType.AA`) manually.\n\n    Args:\n        msa_file (pathlib.Path): Path to the MSA file\n        file_format (FileFormat): File format of the MSA file. Defaults to None. In this case, the file format is determined automatically.\n        data_type (DataType): Data type of the sequences. Defaults to None. In this case, the data type is inferred from the sequences.\n\n    Returns:\n        The parsed MSA object.\n    \"\"\"\n    file_format = file_format or _get_file_format(msa_file)\n    msa_content = StringIO(msa_file.read_text().upper())\n    _msa = AlignIO.read(msa_content, format=file_format.value)\n    sequences = (\n        np.frombuffer(b\"\".join([rec.seq._data for rec in _msa]), dtype=\"S1\")\n        .reshape(len(_msa), -1)\n        .copy()\n    )\n    taxon_names = np.array([rec.id for rec in _msa])\n\n    if not data_type:\n        data_type = _guess_dtype(sequences)\n\n    char_mapping = {c: GAP for c in GAP_CHARS}\n    if data_type == DataType.DNA:\n        # replace all U characters with a T for convenience\n        char_mapping.update({b\"U\": b\"T\"})\n        char_mapping.update({c: GAP for c in DNA_GAP_CHARS})\n\n    for old_char, new_char in char_mapping.items():\n        sequences[sequences == old_char] = new_char\n\n    return MSA(taxon_names, sequences, data_type, msa_file.name)\n</code></pre>"},{"location":"api/msa/#pypythia.msa.remove_full_gap_sequences","title":"<code>pypythia.msa.remove_full_gap_sequences(msa, msa_name=None)</code>","text":"<p>Remove full-gap sequences from the MSA.</p> <p>A full-gap sequence is a sequence where all sites are gaps so the sequence does not contain any information.</p> <p>Parameters:</p> Name Type Description Default <code>msa</code> <code>MSA</code> <p>MSA object to remove full-gap sequences from</p> required <code>msa_name</code> <code>str</code> <p>Name of the new MSA. Defaults to None. In this case, the new MSA is named the same as the input MSA.</p> <code>None</code> <p>Returns:</p> Type Description <code>MSA</code> <p>MSA object without full-gap sequences.</p> <p>Raises:</p> Type Description <code>PyPythiaException</code> <p>If the MSA does not contain any full-gap sequences.</p> Source code in <code>pypythia/msa.py</code> <pre><code>def remove_full_gap_sequences(msa: MSA, msa_name: Optional[str] = None) -&gt; MSA:\n    \"\"\"Remove full-gap sequences from the MSA.\n\n    A full-gap sequence is a sequence where all sites are gaps so the sequence does not contain any information.\n\n    Args:\n        msa (MSA): MSA object to remove full-gap sequences from\n        msa_name (str): Name of the new MSA. Defaults to None. In this case, the new MSA is named the same as the input MSA.\n\n    Returns:\n        MSA object without full-gap sequences.\n\n    Raises:\n        PyPythiaException: If the MSA does not contain any full-gap sequences.\n    \"\"\"\n    if not msa.contains_full_gap_sequences():\n        raise PyPythiaException(\"No full-gap sequences found in MSA.\")\n\n    is_full_gap_sequence = np.all(msa.sequences == GAP, axis=1)\n    non_full_gap_sequences = msa.sequences[~is_full_gap_sequence]\n    non_full_gap_taxa = msa.taxa[~is_full_gap_sequence]\n\n    return MSA(\n        non_full_gap_taxa, non_full_gap_sequences, msa.data_type, msa_name or msa.name\n    )\n</code></pre>"},{"location":"api/msa/#pypythia.msa.deduplicate_sequences","title":"<code>pypythia.msa.deduplicate_sequences(msa, msa_name=None)</code>","text":"<p>Remove duplicate sequences from the MSA.</p> <p>Note that in case of duplicate sequences, the first occurrence (including the first taxon name) is kept and all subsequent occurrences are removed.</p> <p>Parameters:</p> Name Type Description Default <code>msa</code> <code>MSA</code> <p>MSA object to remove duplicate sequences from</p> required <code>msa_name</code> <code>str</code> <p>Name of the new MSA. Defaults to None. In this case, the new MSA is named the same as the input MSA.</p> <code>None</code> <p>Returns:</p> Type Description <code>MSA</code> <p>MSA object without duplicate sequences.</p> <p>Raises:</p> Type Description <code>PyPythiaException</code> <p>If the MSA does not contain any duplicate sequences.</p> Source code in <code>pypythia/msa.py</code> <pre><code>def deduplicate_sequences(msa: MSA, msa_name: Optional[str] = None) -&gt; MSA:\n    \"\"\"Remove duplicate sequences from the MSA.\n\n    Note that in case of duplicate sequences, the first occurrence (including the first taxon name) is kept\n    and all subsequent occurrences are removed.\n\n    Args:\n        msa (MSA): MSA object to remove duplicate sequences from\n        msa_name (str): Name of the new MSA. Defaults to None. In this case, the new MSA is named the same as the input MSA.\n\n    Returns:\n        MSA object without duplicate sequences.\n\n    Raises:\n        PyPythiaException: If the MSA does not contain any duplicate sequences.\n    \"\"\"\n    if not msa.contains_duplicate_sequences():\n        raise PyPythiaException(\"No duplicate sequences found in MSA.\")\n\n    unique_sequences, unique_indices = np.unique(\n        msa.sequences, axis=0, return_index=True\n    )\n    unique_taxa = msa.taxa[unique_indices]\n\n    return MSA(unique_taxa, unique_sequences, msa.data_type, msa_name or msa.name)\n</code></pre>"},{"location":"api/prediction/","title":"prediction","text":""},{"location":"api/prediction/#pypythia.prediction.collect_features","title":"<code>pypythia.prediction.collect_features(msa, msa_file, raxmlng, pars_trees_file=None, log_info=False, threads=None, seed=0)</code>","text":"<p>Helper function to collect all features required for predicting the difficulty of the MSA.</p> <p>Parameters:</p> Name Type Description Default <code>msa</code> <code>MSA</code> <p>MSA object corresponding to the MSA file to compute the features for.</p> required <code>raxmlng</code> <code>RAxMLNG</code> <p>Initialized RAxMLNG object.</p> required <code>pars_trees_file</code> <code>Path</code> <p>Path to store the inferred parsimony trees. Defaults to None. In this case, the trees are not stored.</p> <code>None</code> <code>log_info</code> <code>bool</code> <p>If True, log intermediate progress information using the default logger. Defaults to False.</p> <code>False</code> <code>threads</code> <code>int</code> <p>The number of threads to use for parallel parsimony tree inference. Defaults to None. Uses the RAxML-NG auto parallelization scheme if none is set.</p> <code>None</code> <code>seed</code> <code>int</code> <p>Random seed to use for the parsimony tree inference. Defaults to 0.</p> <code>0</code> <p>Returns:     Dataframe containing a single row with all features required for predicting the difficulty of the MSA.     The columns correspond to the feature names the predictor was trained with.</p> Source code in <code>pypythia/prediction.py</code> <pre><code>def collect_features(\n    msa: MSA,\n    msa_file: pathlib.Path,\n    raxmlng: RAxMLNG,\n    pars_trees_file: Optional[pathlib.Path] = None,\n    log_info: bool = False,\n    threads: int = None,\n    seed: int = 0,\n) -&gt; pd.DataFrame:\n    \"\"\"Helper function to collect all features required for predicting the difficulty of the MSA.\n\n    Args:\n        msa (MSA): MSA object corresponding to the MSA file to compute the features for.\n        raxmlng (RAxMLNG): Initialized RAxMLNG object.\n        pars_trees_file (pathlib.Path, optional): Path to store the inferred parsimony trees. Defaults to None.\n            In this case, the trees are not stored.\n        log_info (bool, optional): If True, log intermediate progress information using the default logger. Defaults to False.\n        threads (int, optional): The number of threads to use for parallel parsimony tree inference. Defaults to None.\n            Uses the RAxML-NG auto parallelization scheme if none is set.\n        seed (int, optional): Random seed to use for the parsimony tree inference. Defaults to 0.\n    Returns:\n        Dataframe containing a single row with all features required for predicting the difficulty of the MSA.\n        The columns correspond to the feature names the predictor was trained with.\n    \"\"\"\n    # If the MSA contains less than 4 sequences, RAxML-NG will fail as there is only a single possible\n    # tree topology for this MSA. In this case, any phylogenetic inference is meaningless and we raise a\n    # PyPythia exception to inform the user.\n    if msa.n_taxa &lt; 4:\n        raise PyPythiaException(\n            \"The MSA contains less than 4 sequences. \"\n            \"Phylogenetic inference is not meaningful for such small MSAs as there exists only a single possible tree topology. \"\n        )\n\n    with TemporaryDirectory() as tmpdir:\n        n_pars_trees = 24\n        log_info and log_runtime_information(\n            f\"Inferring {n_pars_trees} parsimony trees with random seed {seed}.\",\n        )\n        trees = raxmlng.infer_parsimony_trees(\n            msa_file,\n            msa.get_raxmlng_model(),\n            pathlib.Path(tmpdir) / \"pars\",\n            redo=None,\n            seed=seed,\n            n_trees=n_pars_trees,\n            **dict(threads=threads) if threads else {},\n        )\n        if pars_trees_file is not None:\n            log_info and log_runtime_information(\n                f\"Storing the inferred parsimony trees in the file {pars_trees_file}.\"\n            )\n            shutil.copy(trees, pars_trees_file)\n\n        log_info and log_runtime_information(\n            \"Computing the RF-Distance for the parsimony trees.\"\n        )\n        num_topos, rel_rfdist = raxmlng.get_rfdistance_results(trees, redo=None)\n\n        features = {\n            \"num_taxa\": msa.n_taxa,\n            \"num_sites\": msa.n_sites,\n            \"num_patterns\": msa.n_patterns,\n            \"num_patterns/num_taxa\": msa.n_patterns / msa.n_taxa,\n            \"num_sites/num_taxa\": msa.n_sites / msa.n_taxa,\n            \"num_patterns/num_sites\": msa.n_patterns / msa.n_sites,\n            \"proportion_gaps\": msa.proportion_gaps,\n            \"proportion_invariant\": msa.proportion_invariant,\n            \"entropy\": msa.entropy(),\n            \"bollback\": msa.bollback_multinomial(),\n            \"pattern_entropy\": msa.pattern_entropy(),\n            \"avg_rfdist_parsimony\": rel_rfdist,\n            \"proportion_unique_topos_parsimony\": num_topos / n_pars_trees,\n        }\n        return pd.DataFrame(features, index=[0])\n</code></pre>"},{"location":"api/prediction/#pypythia.prediction.predict_difficulty","title":"<code>pypythia.prediction.predict_difficulty(msa_file, raxmlng=DEFAULT_RAXMLNG_EXE, threads=None, seed=0, file_format=None, data_type=None, deduplicate=True, remove_full_gaps=True, result_prefix=None, store_results=True, plot_shap=False, model_file=DEFAULT_MODEL_FILE, log_info=False)</code>","text":"<p>Predict the difficulty of an MSA using the PyPythia difficulty predictor.</p> <p>Per default, the MSA is deduplicated and full gap sequences are removed before the difficulty is predicted.</p> <p>Parameters:</p> Name Type Description Default <code>msa_file</code> <code>Path</code> <p>Path to the MSA file. Note that the MSA file must be in either FASTA or PHYLIP format.</p> required <code>raxmlng</code> <code>Path</code> <p>Path to the RAxML-NG executable. If not set, uses the RAxML-NG binary found in the PATH environment variable.</p> <code>DEFAULT_RAXMLNG_EXE</code> <code>threads</code> <code>int</code> <p>Number of threads to use for parallel parsimony tree inference. If not set, uses the RAxML-NG auto parallelization scheme.</p> <code>None</code> <code>seed</code> <code>int</code> <p>Random seed to use for the parsimony tree inference. Defaults to 0.</p> <code>0</code> <code>file_format</code> <code>FileFormat</code> <p>File format of the MSA file. Defaults to None. In this case, the file format is inferred based on the file content. See <code>pypythia.msa.parse_msa</code> for information on when this is required.</p> <code>None</code> <code>data_type</code> <code>DataType</code> <p>Data type of the MSA sequences. Defaults to None. In this case, the data type is inferred based on the file content. See <code>pypythia.msa.parse_msa</code> for information on when this is required.</p> <code>None</code> <code>deduplicate</code> <code>bool</code> <p>If True, remove duplicate sequences from the MSA. Defaults to True.</p> <code>True</code> <code>remove_full_gaps</code> <code>bool</code> <p>If True, remove full gap sequences from the MSA. Defaults to True.</p> <code>True</code> <code>result_prefix</code> <code>Path</code> <p>Prefix for the result files. Defaults to None. In this case, the prefix is set to the MSA file name.</p> <code>None</code> <code>store_results</code> <code>bool</code> <p>If True, store intermediate results as file. Defaults to True. In this case, the following files are stored: - The reduced MSA in PHYLIP format (if duplicates or full gap sequences were removed) in <code>{result_prefix}.reduced.phy</code> - The inferred parsimony trees in Newick format in <code>{result_prefix}.pythia.trees</code> - The shapley values as waterfall plot in <code>{result_prefix}.shap.pdf</code> (if plot_shap=True) - The features and predicted difficulty as CSV file in <code>{result_prefix}.pythia.csv</code></p> <code>True</code> <code>plot_shap</code> <code>bool</code> <p>If True, plot the shapley values as waterfall plot. Defaults to False.</p> <code>False</code> <code>model_file</code> <code>Path</code> <p>Path to the trained difficulty predictor model. Defaults to the latest model shipped with PyPythia.</p> <code>DEFAULT_MODEL_FILE</code> <code>log_info</code> <code>bool</code> <p>If True, log intermediate progress information using the default logger. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>float64</code> <p>np.float64: Predicted difficulty of the MSA.</p> Source code in <code>pypythia/prediction.py</code> <pre><code>def predict_difficulty(\n    msa_file: pathlib.Path,\n    raxmlng: Optional[pathlib.Path] = DEFAULT_RAXMLNG_EXE,\n    threads: int = None,\n    seed: int = 0,\n    file_format: Optional[FileFormat] = None,\n    data_type: Optional[DataType] = None,\n    deduplicate: bool = True,\n    remove_full_gaps: bool = True,\n    result_prefix: Optional[pathlib.Path] = None,\n    store_results: bool = True,\n    plot_shap: bool = False,\n    model_file: pathlib.Path = DEFAULT_MODEL_FILE,\n    log_info: bool = False,\n) -&gt; np.float64:\n    \"\"\"Predict the difficulty of an MSA using the PyPythia difficulty predictor.\n\n    Per default, the MSA is deduplicated and full gap sequences are removed before the difficulty is predicted.\n\n    Args:\n        msa_file (pathlib.Path): Path to the MSA file. Note that the MSA file must be in either FASTA or PHYLIP format.\n        raxmlng (pathlib.Path, optional): Path to the RAxML-NG executable.\n            If not set, uses the RAxML-NG binary found in the PATH environment variable.\n        threads (int, optional): Number of threads to use for parallel parsimony tree inference. If not set, uses the\n            RAxML-NG auto parallelization scheme.\n        seed (int, optional): Random seed to use for the parsimony tree inference. Defaults to 0.\n        file_format (FileFormat, optional): File format of the MSA file. Defaults to None. In this case, the file format\n            is inferred based on the file content. See `pypythia.msa.parse_msa` for information on when this is required.\n        data_type (DataType, optional): Data type of the MSA sequences. Defaults to None. In this case, the data type\n            is inferred based on the file content. See `pypythia.msa.parse_msa` for information on when this is required.\n        deduplicate (bool, optional): If True, remove duplicate sequences from the MSA. Defaults to True.\n        remove_full_gaps (bool, optional): If True, remove full gap sequences from the MSA. Defaults to True.\n        result_prefix (pathlib.Path, optional): Prefix for the result files. Defaults to None. In this case, the prefix\n            is set to the MSA file name.\n        store_results (bool, optional): If True, store intermediate results as file. Defaults to True.\n            In this case, the following files are stored:\n            - The reduced MSA in PHYLIP format (if duplicates or full gap sequences were removed) in `{result_prefix}.reduced.phy`\n            - The inferred parsimony trees in Newick format in `{result_prefix}.pythia.trees`\n            - The shapley values as waterfall plot in `{result_prefix}.shap.pdf` (if plot_shap=True)\n            - The features and predicted difficulty as CSV file in `{result_prefix}.pythia.csv`\n        plot_shap (bool, optional): If True, plot the shapley values as waterfall plot. Defaults to False.\n        model_file (pathlib.Path): Path to the trained difficulty predictor model.\n            Defaults to the latest model shipped with PyPythia.\n        log_info (bool, optional): If True, log intermediate progress information using the default logger. Defaults to False.\n\n    Returns:\n        np.float64: Predicted difficulty of the MSA.\n    \"\"\"\n    if not msa_file.exists():\n        raise PyPythiaException(f\"The given MSA {msa_file} file does not exist.\")\n\n    if raxmlng is None:\n        raise PyPythiaException(\n            \"Path to the RAxML-NG executable is required if 'raxml-ng' is not in $PATH.\"\n        )\n\n    result_prefix = pathlib.Path(result_prefix) if result_prefix else msa_file\n\n    pars_trees_file = pathlib.Path(f\"{result_prefix}.pythia.trees\")\n    shap_file = pathlib.Path(f\"{result_prefix}.shap.pdf\")\n    results_file = pathlib.Path(f\"{result_prefix}.pythia.csv\")\n\n    # We definitely need to store the reduced MSA somewhere for RAxML-NG\n    if store_results:\n        # If the user wants to keep the results, use the result_prefix\n        reduced_msa_file = pathlib.Path(f\"{result_prefix}.reduced.phy\")\n        _tmpfile = None\n    else:\n        # Else, use a temporary file\n        _tmpfile = tempfile.NamedTemporaryFile(mode=\"w\", suffix=\".phy\")\n        reduced_msa_file = pathlib.Path(_tmpfile.name)\n\n    log_info and log_runtime_information(\n        message=f\"Starting prediction for MSA {msa_file}.\"\n    )\n\n    # Init RAxML-NG\n    try:\n        raxmlng = RAxMLNG(**{\"exe_path\": raxmlng} if raxmlng else {})\n    except Exception as e:\n        raise PyPythiaException(\"Initializing RAxML-NG failed.\") from e\n\n    # Init the prediction model\n    log_info and log_runtime_information(message=f\"Loading predictor {model_file.name}\")\n    try:\n        predictor = DifficultyPredictor(model_file=model_file)\n    except Exception as e:\n        raise PyPythiaException(\"Initializing the difficulty predictor failed.\") from e\n\n    # Load the MSA\n    log_info and log_runtime_information(message=\"Loading MSA\")\n    msa = parse_msa(msa_file, file_format=file_format, data_type=data_type)\n\n    # Deduplicate the MSA if necessary\n    reduced_msa = _handle_duplicates(msa, deduplicate)\n\n    # Remove full gap sequences if necessary\n    reduced_msa = _handle_full_gap_sequences(reduced_msa, remove_full_gaps)\n\n    # Check if the reduced MSA is different from the original MSA\n    is_reduced = msa != reduced_msa\n    if is_reduced:\n        if reduced_msa.n_taxa &lt; 4:\n            raise PyPythiaException(\n                \"During preprocessing, Pythia reduced the input MSA by removing duplicate sequences and/or \"\n                \"sequences containing only gaps leading to an MSA with less than 4 sequences. \"\n                \"RAxML-NG refuses to infer trees for such small MSAs as there exists only a single possible tree topology. \"\n                \"You can rerun the prediction and disable deduplication and gap removal to use the original MSA. \"\n            )\n\n        # If the reduced MSA is different from the original MSA, proceed with the reduced MSA\n        msa = reduced_msa\n\n        log_info and log_runtime_information(\n            \"The input MSA contained duplicate sequences and/or sequences containing only gaps. \"\n            \"WARNING: This predicted difficulty is only applicable to the reduced MSA (duplicate sequences removed). \",\n        )\n\n        # Save the reduced MSA\n        msa_file = reduced_msa_file\n        msa.write(msa_file)\n\n        log_info and log_runtime_information(\n            f\"Saving a reduced alignment as {reduced_msa_file}.\\n\"\n            f\"We recommend to only use the reduced alignment {reduced_msa_file} for your subsequent analyses.\\n\",\n        )\n\n    # Compute the MSA Features\n    log_info and log_runtime_information(\n        f\"Starting to compute MSA features for MSA {msa_file}\"\n    )\n\n    log_info and log_runtime_information(\n        \"Number of threads not specified, using RAxML-NG autoconfig.\"\n        if threads is None\n        else f\"Using {threads} threads for parallel parsimony tree inference.\"\n    )\n\n    msa_features = collect_features(\n        msa=msa,\n        msa_file=msa_file,\n        raxmlng=raxmlng,\n        pars_trees_file=pars_trees_file if store_results else None,\n        log_info=log_info,\n        threads=threads,\n        seed=seed,\n    )\n\n    # Predict the difficulty\n    log_info and log_runtime_information(\"Predicting the difficulty\")\n    difficulty = predictor.predict(msa_features)\n\n    if plot_shap and store_results:\n        # Plot shapley values\n        # this only makes sense if store_results=True, otherwise the figure would be lost\n        fig = predictor.plot_shapley_values(msa_features)\n        fig.tight_layout()\n        fig.savefig(fname=shap_file)\n\n    log_info and log_runtime_information(\"Done\")\n\n    # Log the feature values\n    if log_info:\n        logger.info(\"\u2500\" * 20)\n        logger.info(\"FEATURES: \")\n        for feat, val in msa_features.items():\n            logger.info(f\"{feat}: {round(val[0], 2)}\")\n\n    if store_results:\n        # Write the features + difficulty\n        msa_features[\"difficulty\"] = difficulty\n        msa_features[\"msa_file\"] = str(msa_file)\n\n        msa_features.to_csv(results_file, index=False)\n\n    if log_info:\n        logger.info(\"\")\n        logger.info(f\"Results: {results_file}.\")\n        is_reduced and logger.info(f\"Reduced MSA: {reduced_msa_file}.\")\n        logger.info(f\"Inferred parsimony trees: {pars_trees_file}.\")\n        logger.info(f\"SHAP waterfall plot: {shap_file}.\")\n        logger.warning(\n            \"WARNING: When using shap plots, make sure you understand what shapley values are and how you can interpret\"\n            \" this plot. For details refer to the wiki: https://github.com/tschuelia/PyPythia/wiki/Usage#shapley-values\"\n        )\n\n    if _tmpfile is not None:\n        # store_results was false, so we stored the reduced MSA in a temporary file, which we need to clean up\n        _tmpfile.close()\n\n    return difficulty[0]\n</code></pre>"},{"location":"api/predictor/","title":"predictor","text":""},{"location":"api/predictor/#pypythia.predictor.DifficultyPredictor","title":"<code>pypythia.predictor.DifficultyPredictor</code>","text":"<p>Class structure for the trained difficulty predictor.</p> <p>This class provides methods for predicting the difficulty and plot the shapley values for an MSA.</p> <p>Parameters:</p> Name Type Description Default <code>model_file</code> <code>Path</code> <p>Path to the trained difficulty predictor model. Defaults to the latest model shipped with PyPythia. Note that this model file must be in the LightGBM .txt format.</p> <code>DEFAULT_MODEL_FILE</code> <code>features</code> <code>list[str]</code> <p>Names of the features the predictor was trained with. Defaults to None. In this case, the features are inferred from the model file.</p> <code>None</code> <p>Attributes:</p> Name Type Description <code>predictor</code> <code>Booster</code> <p>The trained LightGBM model used for predicting the difficulty.</p> <code>features</code> <code>list[str]</code> <p>Names of the features the predictor was trained with.</p> Source code in <code>pypythia/predictor.py</code> <pre><code>class DifficultyPredictor:\n    \"\"\"Class structure for the trained difficulty predictor.\n\n    This class provides methods for predicting the difficulty and plot the shapley values for an MSA.\n\n    Args:\n        model_file (pathlib.Path, optional): Path to the trained difficulty predictor model.\n            Defaults to the latest model shipped with PyPythia.\n            Note that this model file must be in the LightGBM .txt format.\n        features (list[str], optional): Names of the features the predictor was trained with.\n            Defaults to None. In this case, the features are inferred from the model file.\n\n    Attributes:\n        predictor (lgb.Booster): The trained LightGBM model used for predicting the difficulty.\n        features (list[str]): Names of the features the predictor was trained with.\n    \"\"\"\n\n    def __init__(\n        self,\n        model_file: Optional[pathlib.Path] = DEFAULT_MODEL_FILE,\n        features: list[str] = None,\n    ) -&gt; None:\n        self.model_file = model_file\n        self.predictor = lgb.Booster(model_file=model_file)\n        self.features = self.predictor.feature_name() if features is None else features\n\n    def __str__(self):\n        return f\"DifficultyPredictor(model_file={self.model_file}, features={self.features})\"\n\n    def __repr__(self):\n        return self.__str__()\n\n    def _check_query(self, query: pd.DataFrame):\n        if not set(self.features).issubset(query.columns):\n            missing_features = set(self.features) - set(query.columns)\n            raise PyPythiaException(\n                \"The provided query does not contain all features the predictor was trained with. \"\n                \"Missing features: \" + \", \".join(missing_features)\n            )\n\n    def predict(self, query: pd.DataFrame) -&gt; npt.NDArray[np.float64]:\n        \"\"\"Predict the difficulty for a set of MSAs defined by rows in the given query dataframe.\n\n        Args:\n            query (pd.DataFrame): DataFrame containing the features for which to predict the difficulty.\n                Each row in the DataFrame corresponds to a single MSA and the columns correspond to the features.\n\n        Returns:\n            A numpy array of predicted difficulties for the provided set of MSAs in float64 format.\n            The difficulties are values in the range [0, 1] where higher values indicate higher difficulty.\n\n        \"\"\"\n        self._check_query(query)\n\n        try:\n            prediction = self.predictor.predict(query[self.features])\n            prediction = prediction.clip(min=0.0, max=1.0)\n            return prediction\n        except Exception as e:\n            raise PyPythiaException(\n                \"An error occurred predicting the difficulty for the provided set of MSA features.\"\n            ) from e\n\n    def plot_shapley_values(self, query: pd.DataFrame) -&gt; Figure:\n        \"\"\"Plot the shapley values for the **first** MSA in the given query dataframe.\n\n        Please read our notes on SHAP values in the documentation to understand the plot.\n\n        Args:\n            query (pd.DataFrame): DataFrame containing the features for which to plot the shapley values.\n\n        Returns:\n            A matplotlib Figure object containing the waterfall plot of the shapley values for the first MSA in the query.\n        \"\"\"\n        with warnings.catch_warnings():\n            warnings.simplefilter(\"ignore\")\n            import shap\n\n        self._check_query(query)\n\n        df = query[self.features]\n\n        explainer = shap.TreeExplainer(self.predictor)\n        shap_values = explainer.shap_values(df)\n        base_values = explainer.expected_value\n\n        return shap.plots.waterfall(\n            shap.Explanation(\n                values=shap_values[0], base_values=base_values, data=df.iloc[0]\n            ),\n            show=False,\n        ).figure\n</code></pre>"},{"location":"api/predictor/#pypythia.predictor.DifficultyPredictor.plot_shapley_values","title":"<code>plot_shapley_values(query)</code>","text":"<p>Plot the shapley values for the first MSA in the given query dataframe.</p> <p>Please read our notes on SHAP values in the documentation to understand the plot.</p> <p>Parameters:</p> Name Type Description Default <code>query</code> <code>DataFrame</code> <p>DataFrame containing the features for which to plot the shapley values.</p> required <p>Returns:</p> Type Description <code>Figure</code> <p>A matplotlib Figure object containing the waterfall plot of the shapley values for the first MSA in the query.</p> Source code in <code>pypythia/predictor.py</code> <pre><code>def plot_shapley_values(self, query: pd.DataFrame) -&gt; Figure:\n    \"\"\"Plot the shapley values for the **first** MSA in the given query dataframe.\n\n    Please read our notes on SHAP values in the documentation to understand the plot.\n\n    Args:\n        query (pd.DataFrame): DataFrame containing the features for which to plot the shapley values.\n\n    Returns:\n        A matplotlib Figure object containing the waterfall plot of the shapley values for the first MSA in the query.\n    \"\"\"\n    with warnings.catch_warnings():\n        warnings.simplefilter(\"ignore\")\n        import shap\n\n    self._check_query(query)\n\n    df = query[self.features]\n\n    explainer = shap.TreeExplainer(self.predictor)\n    shap_values = explainer.shap_values(df)\n    base_values = explainer.expected_value\n\n    return shap.plots.waterfall(\n        shap.Explanation(\n            values=shap_values[0], base_values=base_values, data=df.iloc[0]\n        ),\n        show=False,\n    ).figure\n</code></pre>"},{"location":"api/predictor/#pypythia.predictor.DifficultyPredictor.predict","title":"<code>predict(query)</code>","text":"<p>Predict the difficulty for a set of MSAs defined by rows in the given query dataframe.</p> <p>Parameters:</p> Name Type Description Default <code>query</code> <code>DataFrame</code> <p>DataFrame containing the features for which to predict the difficulty. Each row in the DataFrame corresponds to a single MSA and the columns correspond to the features.</p> required <p>Returns:</p> Type Description <code>NDArray[float64]</code> <p>A numpy array of predicted difficulties for the provided set of MSAs in float64 format.</p> <code>NDArray[float64]</code> <p>The difficulties are values in the range [0, 1] where higher values indicate higher difficulty.</p> Source code in <code>pypythia/predictor.py</code> <pre><code>def predict(self, query: pd.DataFrame) -&gt; npt.NDArray[np.float64]:\n    \"\"\"Predict the difficulty for a set of MSAs defined by rows in the given query dataframe.\n\n    Args:\n        query (pd.DataFrame): DataFrame containing the features for which to predict the difficulty.\n            Each row in the DataFrame corresponds to a single MSA and the columns correspond to the features.\n\n    Returns:\n        A numpy array of predicted difficulties for the provided set of MSAs in float64 format.\n        The difficulties are values in the range [0, 1] where higher values indicate higher difficulty.\n\n    \"\"\"\n    self._check_query(query)\n\n    try:\n        prediction = self.predictor.predict(query[self.features])\n        prediction = prediction.clip(min=0.0, max=1.0)\n        return prediction\n    except Exception as e:\n        raise PyPythiaException(\n            \"An error occurred predicting the difficulty for the provided set of MSA features.\"\n        ) from e\n</code></pre>"},{"location":"api/raxmlng/","title":"raxmlng","text":""},{"location":"api/raxmlng/#pypythia.raxmlng.RAxMLNG","title":"<code>pypythia.raxmlng.RAxMLNG</code>","text":"<p>Class to interact with the RAxML-NG binary.</p> <p>Parameters:</p> Name Type Description Default <code>exe_path</code> <code>Path</code> <p>Path to the RAxML-NG executable. Defaults to the binary found in the PATH environment variable.</p> <code>DEFAULT_RAXMLNG_EXE</code> <p>Attributes:</p> Name Type Description <code>exe_path</code> <code>Path</code> <p>Path to the RAxML-NG executable.</p> <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>If the RAxML-NG executable is not found.</p> <code>RuntimeError</code> <p>If the RAxML-NG executable is not working or is not a RAxML-NG executable.</p> Source code in <code>pypythia/raxmlng.py</code> <pre><code>class RAxMLNG:\n    \"\"\"Class to interact with the RAxML-NG binary.\n\n    Args:\n        exe_path (pathlib.Path, optional): Path to the RAxML-NG executable. Defaults to the binary found in the PATH environment variable.\n\n    Attributes:\n        exe_path (pathlib.Path): Path to the RAxML-NG executable.\n\n    Raises:\n        FileNotFoundError: If the RAxML-NG executable is not found.\n        RuntimeError: If the RAxML-NG executable is not working or is not a RAxML-NG executable.\n\n    \"\"\"\n\n    def __init__(self, exe_path: Optional[pathlib.Path] = DEFAULT_RAXMLNG_EXE):\n        if exe_path is None or not exe_path.exists():\n            raise FileNotFoundError(\"RAxML-NG executable not found.\")\n\n        try:\n            out = subprocess.check_output([str(exe_path.absolute())], encoding=\"utf-8\")\n        except Exception as e:\n            raise RuntimeError(\n                f\"Your RAxML-NG executable does not seem to work. Running `{exe_path}` failed: {e}\"\n            ) from e\n\n        if not \"RAxML-NG\" in out:\n            raise RuntimeError(\n                f\"The given executable `{exe_path}` does not seem to be a RAxML-NG executable.\"\n            )\n\n        self.exe_path = exe_path\n\n    def _base_cmd(\n        self, msa_file: pathlib.Path, model: str, prefix: pathlib.Path, **kwargs\n    ) -&gt; list[str]:\n        additional_settings = []\n        for key, value in kwargs.items():\n            if value is None:\n                additional_settings += [f\"--{key}\"]\n            else:\n                additional_settings += [f\"--{key}\", str(value)]\n\n        return [\n            str(self.exe_path.absolute()),\n            \"--msa\",\n            str(msa_file.absolute()),\n            \"--model\",\n            model,\n            \"--prefix\",\n            str(prefix.absolute()),\n            *additional_settings,\n        ]\n\n    def _run_rfdist(\n        self, trees_file: pathlib.Path, prefix: pathlib.Path, **kwargs\n    ) -&gt; None:\n        additional_settings = []\n        for key, value in kwargs.items():\n            if value is None:\n                additional_settings += [f\"--{key}\"]\n            else:\n                additional_settings += [f\"--{key}\", str(value)]\n        cmd = [\n            str(self.exe_path.absolute()),\n            \"--rfdist\",\n            str(trees_file.absolute()),\n            \"--prefix\",\n            str(prefix.absolute()),\n            *additional_settings,\n        ]\n        run_raxmlng_command(cmd)\n\n    def infer_parsimony_trees(\n        self,\n        msa_file: pathlib.Path,\n        model: str,\n        prefix: pathlib.Path,\n        n_trees: int = 24,\n        **kwargs,\n    ) -&gt; pathlib.Path:\n        \"\"\"Method that infers n_trees using the RAxML-NG implementation of maximum parsimony.\n\n        Args:\n            msa_file (pathlib.Path): Filepath pointing to the MSA file.\n            model (str): String representation of the substitution model to use. Needs to be a valid RAxML-NG model.\n                For example \"GTR+G\" for DNA data or \"LG+G\" for protein data.\n            prefix (pathlib.Path): Prefix to use when running RAxML-NG.\n            n_trees (int): Number of trees to infer. Defaults to 24.\n            **kwargs: Additional arguments to pass to the RAxML-NG command.\n                The name of the kwarg needs to be a valid RAxML-NG flag.\n                For flags with a value pass it like this: \"flag=value\", for flags without a value pass it like this: \"flag=None\".\n                See https://github.com/amkozlov/raxml-ng for all options.\n\n        Returns:\n            Filepath pointing to the inferred maximum parsimony trees.\n        \"\"\"\n        cmd = self._base_cmd(\n            msa_file, model, prefix, start=None, tree=f\"pars{{{n_trees}}}\", **kwargs\n        )\n        run_raxmlng_command(cmd)\n        return pathlib.Path(f\"{prefix}.raxml.startTree\")\n\n    def get_rfdistance_results(\n        self, trees_file: pathlib.Path, prefix: pathlib.Path = None, **kwargs\n    ) -&gt; tuple[float, float]:\n        \"\"\"Method that computes the number of unique topologies and the relative RF-Distance for the given set of trees.\n\n        Args:\n            trees_file (pathlib.Path): Filepath pointing to the file containing the trees.\n            prefix (pathlib.Path, optional): Prefix to use when running RAxML-NG. Defaults to None. If None, a temporary directory is used.\n            **kwargs: Additional arguments to pass to the RAxML-NG command.\n                The name of the kwarg needs to be a valid RAxML-NG flag.\n                For flags with a value pass it like this: \"flag=value\", for flags without a value pass it like this: \"flag=None\".\n                See\n\n        Returns:\n            num_topos (float): Number of unique topologies of the given set of trees.\n            rel_rfdist (float): Relative RF-Distance of the given set of trees. Computed as average over all pairwise RF-Distances. Value between 0.0 and 1.0.\n        \"\"\"\n        with TemporaryDirectory() as tmpdir:\n            tmpdir = pathlib.Path(tmpdir)\n            if not prefix:\n                prefix = tmpdir / \"rfdist\"\n            self._run_rfdist(trees_file, prefix, **kwargs)\n            log_file = pathlib.Path(f\"{prefix}.raxml.log\")\n            return get_raxmlng_rfdist_results(log_file)\n</code></pre>"},{"location":"api/raxmlng/#pypythia.raxmlng.RAxMLNG.get_rfdistance_results","title":"<code>get_rfdistance_results(trees_file, prefix=None, **kwargs)</code>","text":"<p>Method that computes the number of unique topologies and the relative RF-Distance for the given set of trees.</p> <p>Parameters:</p> Name Type Description Default <code>trees_file</code> <code>Path</code> <p>Filepath pointing to the file containing the trees.</p> required <code>prefix</code> <code>Path</code> <p>Prefix to use when running RAxML-NG. Defaults to None. If None, a temporary directory is used.</p> <code>None</code> <code>**kwargs</code> <p>Additional arguments to pass to the RAxML-NG command. The name of the kwarg needs to be a valid RAxML-NG flag. For flags with a value pass it like this: \"flag=value\", for flags without a value pass it like this: \"flag=None\". See</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>num_topos</code> <code>float</code> <p>Number of unique topologies of the given set of trees.</p> <code>rel_rfdist</code> <code>float</code> <p>Relative RF-Distance of the given set of trees. Computed as average over all pairwise RF-Distances. Value between 0.0 and 1.0.</p> Source code in <code>pypythia/raxmlng.py</code> <pre><code>def get_rfdistance_results(\n    self, trees_file: pathlib.Path, prefix: pathlib.Path = None, **kwargs\n) -&gt; tuple[float, float]:\n    \"\"\"Method that computes the number of unique topologies and the relative RF-Distance for the given set of trees.\n\n    Args:\n        trees_file (pathlib.Path): Filepath pointing to the file containing the trees.\n        prefix (pathlib.Path, optional): Prefix to use when running RAxML-NG. Defaults to None. If None, a temporary directory is used.\n        **kwargs: Additional arguments to pass to the RAxML-NG command.\n            The name of the kwarg needs to be a valid RAxML-NG flag.\n            For flags with a value pass it like this: \"flag=value\", for flags without a value pass it like this: \"flag=None\".\n            See\n\n    Returns:\n        num_topos (float): Number of unique topologies of the given set of trees.\n        rel_rfdist (float): Relative RF-Distance of the given set of trees. Computed as average over all pairwise RF-Distances. Value between 0.0 and 1.0.\n    \"\"\"\n    with TemporaryDirectory() as tmpdir:\n        tmpdir = pathlib.Path(tmpdir)\n        if not prefix:\n            prefix = tmpdir / \"rfdist\"\n        self._run_rfdist(trees_file, prefix, **kwargs)\n        log_file = pathlib.Path(f\"{prefix}.raxml.log\")\n        return get_raxmlng_rfdist_results(log_file)\n</code></pre>"},{"location":"api/raxmlng/#pypythia.raxmlng.RAxMLNG.infer_parsimony_trees","title":"<code>infer_parsimony_trees(msa_file, model, prefix, n_trees=24, **kwargs)</code>","text":"<p>Method that infers n_trees using the RAxML-NG implementation of maximum parsimony.</p> <p>Parameters:</p> Name Type Description Default <code>msa_file</code> <code>Path</code> <p>Filepath pointing to the MSA file.</p> required <code>model</code> <code>str</code> <p>String representation of the substitution model to use. Needs to be a valid RAxML-NG model. For example \"GTR+G\" for DNA data or \"LG+G\" for protein data.</p> required <code>prefix</code> <code>Path</code> <p>Prefix to use when running RAxML-NG.</p> required <code>n_trees</code> <code>int</code> <p>Number of trees to infer. Defaults to 24.</p> <code>24</code> <code>**kwargs</code> <p>Additional arguments to pass to the RAxML-NG command. The name of the kwarg needs to be a valid RAxML-NG flag. For flags with a value pass it like this: \"flag=value\", for flags without a value pass it like this: \"flag=None\". See https://github.com/amkozlov/raxml-ng for all options.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Path</code> <p>Filepath pointing to the inferred maximum parsimony trees.</p> Source code in <code>pypythia/raxmlng.py</code> <pre><code>def infer_parsimony_trees(\n    self,\n    msa_file: pathlib.Path,\n    model: str,\n    prefix: pathlib.Path,\n    n_trees: int = 24,\n    **kwargs,\n) -&gt; pathlib.Path:\n    \"\"\"Method that infers n_trees using the RAxML-NG implementation of maximum parsimony.\n\n    Args:\n        msa_file (pathlib.Path): Filepath pointing to the MSA file.\n        model (str): String representation of the substitution model to use. Needs to be a valid RAxML-NG model.\n            For example \"GTR+G\" for DNA data or \"LG+G\" for protein data.\n        prefix (pathlib.Path): Prefix to use when running RAxML-NG.\n        n_trees (int): Number of trees to infer. Defaults to 24.\n        **kwargs: Additional arguments to pass to the RAxML-NG command.\n            The name of the kwarg needs to be a valid RAxML-NG flag.\n            For flags with a value pass it like this: \"flag=value\", for flags without a value pass it like this: \"flag=None\".\n            See https://github.com/amkozlov/raxml-ng for all options.\n\n    Returns:\n        Filepath pointing to the inferred maximum parsimony trees.\n    \"\"\"\n    cmd = self._base_cmd(\n        msa_file, model, prefix, start=None, tree=f\"pars{{{n_trees}}}\", **kwargs\n    )\n    run_raxmlng_command(cmd)\n    return pathlib.Path(f\"{prefix}.raxml.startTree\")\n</code></pre>"},{"location":"api/raxmlng/#pypythia.raxmlng.run_raxmlng_command","title":"<code>pypythia.raxmlng.run_raxmlng_command(cmd)</code>","text":"<p>Helper method to run a RAxML-NG command.</p> <p>Parameters:</p> Name Type Description Default <code>cmd</code> <code>list</code> <p>List of strings representing the RAxML-NG command to run.</p> required <p>Raises:</p> Type Description <code>RAxMLNGError</code> <p>If the RAxML-NG command fails with a CalledProcessError.</p> <code>RuntimeError</code> <p>If the RAxML-NG command fails with any other error.</p> Source code in <code>pypythia/raxmlng.py</code> <pre><code>def run_raxmlng_command(cmd: list[str]) -&gt; None:\n    \"\"\"Helper method to run a RAxML-NG command.\n\n    Args:\n        cmd (list): List of strings representing the RAxML-NG command to run.\n\n    Raises:\n        RAxMLNGError: If the RAxML-NG command fails with a CalledProcessError.\n        RuntimeError: If the RAxML-NG command fails with any other error.\n    \"\"\"\n    try:\n        subprocess.check_output(cmd, encoding=\"utf-8\")\n    except subprocess.CalledProcessError as e:\n        raise RAxMLNGError(subprocess_exception=e)\n    except Exception as e:\n        raise RuntimeError(\"Running RAxML-NG command failed.\") from e\n</code></pre>"},{"location":"api/raxmlng/#pypythia.raxmlng.get_raxmlng_rfdist_results","title":"<code>pypythia.raxmlng.get_raxmlng_rfdist_results(log_file)</code>","text":"<p>Method to parse the RAxML-NG log file and extract the number of unique topologies and relative RF-Distance. Args:     log_file (pathlib.Path): Filepath pointing to the RAxML-NG log file.</p> <p>Returns:</p> Name Type Description <code>num_topos</code> <code>float</code> <p>Number of unique topologies of the given set of trees.</p> <code>rel_rfdist</code> <code>float</code> <p>Relative RF-Distance of the given set of trees. Computed as average over all pairwise RF-Distances. Value between 0.0 and 1.0.</p> Source code in <code>pypythia/raxmlng.py</code> <pre><code>def get_raxmlng_rfdist_results(log_file: pathlib.Path) -&gt; tuple[int, float]:\n    \"\"\"\n    Method to parse the RAxML-NG log file and extract the number of unique topologies and relative RF-Distance.\n    Args:\n        log_file (pathlib.Path): Filepath pointing to the RAxML-NG log file.\n\n    Returns:\n        num_topos (float): Number of unique topologies of the given set of trees.\n        rel_rfdist (float): Relative RF-Distance of the given set of trees. Computed as average over all pairwise RF-Distances. Value between 0.0 and 1.0.\n\n    \"\"\"\n    rel_rfdist = None\n    num_topos = None\n\n    for line in log_file.open().readlines():\n        line = line.strip()\n\n        if \"Average relative RF distance in this tree set:\" in line:\n            rel_rfdist = _get_value_from_line(\n                line, \"Average relative RF distance in this tree set:\"\n            )\n        elif \"Number of unique topologies in this tree set:\" in line:\n            num_topos = _get_value_from_line(\n                line, \"Number of unique topologies in this tree set:\"\n            )\n\n    if rel_rfdist is None or num_topos is None:\n        raise ValueError(\"Error parsing raxml-ng log.\")\n\n    return int(num_topos), rel_rfdist\n</code></pre>"}]}