{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>Welcome to the PyPythia documentation. Pythia is a lightweight python library to predict the difficulty of Multiple Sequence Alignments (MSAs).</p>"},{"location":"#c-library","title":"C Library","text":"<p>The same functionality is also available as C library here. Since the C library depends on Coraxlib it is not as easy and fast to use as this python library. If you are only interested in the difficulty of your MSA, we recommend using this Python library. If you want to incorporate the difficulty prediction in a phylogenetic tool, we recommend using the faster C library.</p>"},{"location":"#support","title":"Support","text":"<p>If you encounter any trouble using Pythia, have a question, or you find a bug, please feel free to open an issue here.</p>"},{"location":"#publication","title":"Publication","text":"<p>The paper explaining the details of Pythia is published in MBE: Haag, J., H\u00f6hler, D., Bettisworth, B., &amp; Stamatakis, A. (2022). From Easy to Hopeless - Predicting the Difficulty of Phylogenetic Analyses. Molecular Biology and Evolution, 39(12). https://doi.org/10.1093/molbev/msac254</p> <p>Warning</p> <p>Since this publication, we made some considerable changes to Pythia. The most important change is that we switched from using a Random Forest Regressor to using a LightGBM Gradient Boosted Tree Regressor. This affects all Pythia versions &gt;= 1. If you use Pythia in your work, please state the correct learning algorithm. If you are unsure, feel free to reach out to me \ud83d\ude42</p>"},{"location":"#references","title":"References","text":"<ul> <li> <p>A. M. Kozlov, D. Darriba, T. Flouri, B. Morel, and A. Stamatakis (2019) RAxML-NG: a fast, scalable and user-friendly tool for maximum likelihood phylogenetic inference Bioinformatics, 35(21): 4453\u20134455. https://doi.org/10.1093/bioinformatics/btz305</p> </li> <li> <p>D. H\u00f6hler, W. Pfeiffer, V. Ioannidis, H. Stockinger, A. Stamatakis (2022) RAxML Grove: an empirical phylogenetic tree database Bioinformatics, 38(6):1741\u20131742. https://doi.org/10.1093/bioinformatics/btab863</p> </li> </ul> <p>For full documentation visit mkdocs.org.</p>"},{"location":"install/","title":"Install","text":""},{"location":"install/#requirements","title":"Requirements","text":"<p>In order to use this difficulty prediction, you need RAxML-NG installed somewhere on your system. You can find the install instructions here.</p>"},{"location":"install/#install-using-conda-recommended","title":"Install using conda (recommended)","text":"<p>The easiest (and recommended) way to install PyPythia is by using conda:</p> <pre><code>conda install pypythia -c conda-forge -c nodefaults\n</code></pre>"},{"location":"install/#install-using-pip","title":"Install using pip","text":"<p>You can also install Pythia using the python package manager pip:</p> <pre><code>pip install git+https://github.com/tschuelia/PyPythia.git\n</code></pre> <p>Please note that this can lead to issues with package versions and dependencies when installing in an existing (conda) environment.</p> <p>Verify the correct installation by running <code>pythia -h</code>.</p>"},{"location":"install/#installing-a-specific-tagversion","title":"Installing a specific tag/version","text":"<p>You can again use pip for this and simply specify the tag you wish to install, e.g. for version <code>0.0.1</code> run:</p> <pre><code>pip install git+https://github.com/tschuelia/PyPythia.git@0.0.1\n</code></pre>"},{"location":"install/#installation-from-source","title":"Installation from source","text":"<p>You can install Pythia from source if you want to explore the code or get the lastest development version. To do so run the following steps:</p> <pre><code>git clone https://github.com/tschuelia/PyPythia.git\ncd PyPythia\npip install .\n</code></pre> <p>Verify the correct installation by running <code>pythia -h</code>.</p>"},{"location":"install/#troubleshooting","title":"Troubleshooting","text":"<p>Most issues when installing Pythia seem to arise from broken or non-working LightGBM installations. If you encounter any such problem, and none of the following options help, please refer to the LightGBM installation instructions for your operating system and install LightGBM manually before repeating the Pythia installation as described above.</p>"},{"location":"install/#python-version","title":"Python version","text":"<p>Since Pythia version 1.1.0 we provide the option to output the Shapley values for your prediction. Currently, the <code>shap</code> package does not support Python Version 3.11. The requirements should take care of the correct Python version, but if you encounter any issues, please first check that the Python version is &lt;3.11. You can do so by typing <code>python --version</code> in your terminal and checking the output.</p>"},{"location":"install/#installing-on-m1-chips","title":"Installing on M1 chips","text":"<p>Installing on MacBooks with M1 chips caused some trouble for some users that seem to be caused by LightGBM's multiprocessing support. If you encounter any errors with the log pointing to LightGBM, the first thing you could try is to install LightGBM using homebrew:</p> <pre><code>brew install lightgbm\n</code></pre> <p>This might take a few minutes to finish. Once this ran successfully you can try to rerun the install instructions above.</p> <p>If this does not solve your problem, you can try to install LightGBM manually using pip and disabling the multiprocessing:</p> <pre><code>pip install lightgbm --install-option=--nomp\n</code></pre> <p>and then rerun the installation of PyPythia. Thanks @willbour for finding the fix for this!</p>"},{"location":"install/#using-a-clean-conda-environment","title":"Using a clean conda environment","text":"<p>When using conda and installing PyPythia using pip in an existing environment, you might encounter dependency or version related issues. To check whether this is the case or you have a general issue with Pythia please try to create a new, clean conda environment:</p> <ol> <li>Use the provided environment file <code>etc/environment.yml</code> and create a new conda environment:</li> </ol> <pre><code>conda env create --file etc/environment.yml\n</code></pre> <p>If you want to install a different version of Pythia, you can add the git tag by appending <code>@[version]</code> (e.g. for version 1.1.0 append <code>@1.1.0</code>) after <code>.git</code> in the <code>etc/environment.yml</code> file.</p> <ol> <li>Activate the conda environment: <code>conda activate pythia</code></li> <li>Try to (re)run Pythia.</li> </ol>"},{"location":"install/#running-pythia","title":"Running Pythia","text":"<p>If you are having trouble running pythia, you can also replace <code>pythia</code> with <code>python pypythia/prediction.py</code>. For this to work you need to install Pythia from source and you need to be in the PyPythia directory (which you should be after the installation).</p> <p>If this does not work either, as of version 1.0.1, PyPythia includes a Python script that allows predictions from code without installing Pythia. See the Usage wiki page for more details.</p>"},{"location":"usage/","title":"User Guide","text":"<p>This library can be used in two ways: either directly as command line tool, or the prediction can be called from other python code.</p>"},{"location":"usage/#command-line-tool","title":"Command Line Tool","text":"<p>If you only want to predict the difficulty for a single MSA, you can query the predictor using the command line interface, for example like this:</p> <pre><code>pythia --msa examples/example.phy --raxmlng /path/to/raxml-ng\n</code></pre> <p>Note that when you installed PyPythia using conda, you will have to download the <code>example.phy</code> and adjust the path accordingly.</p> <p>The output will be something like <code>The predicted difficulty for MSA examples/example.phy is: 0.16.</code>, telling us that example.phy is an easy dataset. In fact, this dataset exhibits a single likelihood peak. Depending on the predictor version you are using, the actual value might slightly differ. This is expected and nothing to worry about \ud83d\ude42</p> <p>Note that Pythia can also handle FASTA input files, see section Input Data below.</p> <p>The following options are available:</p> <pre><code>PyPythia version 1.2.0 released by The Exelixis Lab\nDeveloped by: Julia Haag\nLatest version: https://github.com/tschuelia/PyPythia\nQuestions/problems/suggestions? Please open an issue on GitHub.\n\nusage: pythia [-h] -m MSA -r RAXMLNG [-t THREADS] [-p PREDICTOR] [-o OUTPUT] [-prec PRECISION] [-sT] [--removeDuplicates] [--forceDuplicates]\n              [--shap] [-v] [-b] [-q]\n\nParser for Pythia command line options.\n\noptions:\n  -h, --help            show this help message and exit\n  -m MSA, --msa MSA     Multiple Sequence Alignment to predict the difficulty for. Must be in either phylip or fasta format.\n  -r RAXMLNG, --raxmlng RAXMLNG\n                        Path to the binary of RAxML-NG. For install instructions see https://github.com/amkozlov/raxml-ng.\n  -t THREADS, --threads THREADS\n                        Number of threads to use for parallel parsimony tree inference. If none is set, Pythia uses the parallelization scheme\n                        of RAxML-NG that automatically detects the optimal number of threads for your machine.\n  -p PREDICTOR, --predictor PREDICTOR\n                        Filepath of the predictor to use. If not set, assume it is 'predictors/latest.pckl' in the project directory.\n  -o OUTPUT, --output OUTPUT\n                        Option to specify a filepath where the result will be written to. The file will contain a single line with only the\n                        difficulty.\n  -prec PRECISION, --precision PRECISION\n                        Set the number of decimals the difficulty should be rounded to. Recommended and default is 2.\n  -sT, --storeTrees     If set, stores the parsimony trees as '{msa_name}.parsimony.trees' file.\n  --removeDuplicates    Pythia refuses to predict the difficulty for MSAs containing duplicate sequences. If this option is set, PyPythia\n                        removes the duplicate sequences, stores the reduced MSA as '{msa_name}.{phy/fasta}.pythia.reduced' and predicts the\n                        difficulty for the reduced alignment.\n  --forceDuplicates     Per default, Pythia refuses to predict the difficulty for MSAs containing duplicate sequences. Set this option if you\n                        are absolutely sure that you want to predict the difficulty for this MSA.\n  --shap                If set, computes the shapley values of the prediction as waterfall plot in '{msa_name}.shap.pdf'. When using this\n                        option, make sure you understand what shapley values are and how to interpret this plot.For details on shapley values\n                        refer to the wiki: https://github.com/tschuelia/PyPythia/wiki/Usage#shapley-values.\n  -v, --verbose         If set, additionally prints the MSA features.\n  -b, --benchmark       If set, time the runtime of the prediction.\n  -q, --quiet           If set, Pythia does not print progress updates and only prints the predicted difficulty.\n</code></pre>"},{"location":"usage/#from-code","title":"From Code","text":"<p>You can also use the library as a regular python library by installing it in your current environment. Then you can query the prediction like this:</p> <pre><code>from pypythia.predictor import DifficultyPredictor\nfrom pypythia.prediction import get_all_features\nfrom pypythia.raxmlng import RAxMLNG\nfrom pypythia.msa import MSA\n\npredictor = DifficultyPredictor(open(\"pypythia/predictors/latest.pckl\", \"rb\"))\nraxmlng = RAxMLNG(\"/path/to/raxml-ng\")\nmsa = MSA(\"examples/example.phy\")\n\nmsa_features = get_all_features(raxmlng, msa)\ndifficulty = predictor.predict(msa_features)\nprint(difficulty)\n</code></pre> <p>Note that Pythia can also handle FASTA input files, see section Input Data below.</p>"},{"location":"usage/#using-python-multiprocessing","title":"Using Python multiprocessing","text":"<p>There are reported issues with multiprocessing in Python and LightGBM based predictors (see for example the LightGBM FAQ). We added a type check in the <code>predictor.py</code> prediction code that sets the number of threads to 1 for the prediction (<code>num_threads=1</code>) if the predictor is a LightGBM predictor. This should not affect the previous Pythia versions using the scikit-learn predictors. Since the multithreading issues do not occur consistently, this issue is hard to debug. If you encounter any issues with Python multiprocessing and Pythia please open a GitHub issue.</p>"},{"location":"usage/#usage-without-installation","title":"Usage Without Installation","text":"<p>As of version 1.0.1, PyPythia includes a script <code>prediction_no_install.py</code> in the root directory. This script contains the single function <code>predict_difficulty</code>. Provided a path to an MSA, a path to a trained difficulty predictor (e.g. <code>pypythia/predictors/latest.pckl</code>), and a path to an executable of RAxML-NG, this fucntion returns the predicted difficulty without requiring an installation of PyPythia. Note that this script can only be called from PyPythia's root directory.</p> <p>To use this script, open it using your favorite text editor / python IDE and add the following at the end:</p> <pre><code>msa_file = \"path/to/your/msa\"  # the file path of your MSA, can be either relative or absolute\nraxmlng_exe_path = \"path/to/raxml-ng/bin/raxml-ng\"  # path pointing to the RAxML-NG executable on your system\npredictor_path = \"pypythia/predictors/latest.pckl\"\npredict_difficulty(msa_file, predictor_path, raxmlng_exe_path)\n</code></pre>"},{"location":"usage/#input-data","title":"Input data","text":""},{"location":"usage/#supported-file-types","title":"Supported file types","text":"<p>The input for Pythia is an MSA file in either Phylip or FASTA format.</p>"},{"location":"usage/#supported-data-types","title":"Supported  data types","text":"<p>Pythia supports DNA, AA, and morphological data.</p> <p>Please note that by morphological data we refer to biological data. According to our analyses, the attributes of biological morphological data are similar to the attributes of DNA and AA data. However, when analyzing language data (cognate, sound-class, and morphosyntactic data) we observed substantially distinct attributes and concluded that morphological language data is not comparable to DNA, AA, or biological morphological data. Thus, at the moment Pythia is not able to reliably predict the difficulty for language alignments.</p>"},{"location":"usage/#taxon-names","title":"Taxon names","text":"<p>Make sure that the MSA only contains RAxML-NG compatible taxon names. In particular, taxon labels with spaces, tabs, newlines, commas, colons, semicolons and parenthesis are invalid.</p>"},{"location":"usage/#msas-with-duplicate-sequences","title":"MSAs with duplicate sequences","text":"<p>As of version 1.0.0 Pythia refuses to predict the difficulty for MSAs containing multiple exactly identical sequences (duplicate sequences). The reason for this is that duplicate sequences can have a substantial impact on the resulting topologies during the maximum parsimony tree inference and therefore on the topological distance measures.</p> <p>If you set the command line option <code>--removeDuplicates</code>, Pythia will create a reduced alignment with all duplicates removed and predict the difficulty for this reduced alignment. For duplicate sequences, the first occurrence of the sequence is kept. WARNING: The resulting predicted difficulty is only applicable to the reduced MSA! We recommend to only use the created reduced alignment for your subsequent analyses.</p>"},{"location":"usage/#predictors","title":"Predictors","text":"<p>To continuously and automatically improve the prediction accuracy of Pythia, we regularly extend the training data set and subsequently retrain the predictor. We extend the training data using the anonymized MSAs that we continuously obtain during our RAxML Grove database updates. Note that these MSAs are only available internally in RAxML Grove and are not publicly available. As per default, PyPythia uses the lastest predictor <code>predictors/latest.pckl</code>. Older versions of the trained predictors are available in the <code>predictors</code> directory and can be passed to Pythia (see Usage instructions above). All predictors of versions &gt;= 1.0.0 are trained using DNA, AA, and morphological MSAs.</p> <p>Note that the predictions for the same MSA can be different when using different versions of Pythia.</p>"},{"location":"usage/#shapley-values","title":"Shapley Values","text":"<p>As of version 1.1.0, Pythia includes an option to plot Shapley values for a prediction. The interpretation of Shapley values is not straight-forward and we emphasize the importance of learning about these values before drawing conclusions based on the resulting plot! We provide the Shapley values as waterfall plot. In the following, we briefly describe what Shapley values are, what a waterfall plot is, and how you can interpret this plot. It is important to note that Shapley values are not the same as feature importances. Predicting the difficulty of two distinct MSAs will lead to two distinct waterfall plots.</p>"},{"location":"usage/#shapley-values_1","title":"Shapley Values","text":"<p>Based on the training data, our difficulty predictor Pythia has learned a base line difficulty. This base line difficulty is the expected value for every new prediction. Starting off this base line, Pythia adjusts its prediction using the features of the MSA. To determine how much each feature contributes to this change, ultimately leading to the final prediction is estimated by Shapley values. Since Pythia is a tree-based regressor, computing the Shapley values requires some advanced mathematics that I won't go into detail about here. If you are interested in this check out the links in the More Details section below. Due to the calculation of Shapley values, the value for one feature is NOT the difference in prediction when removing this feature. The Shapley value for one feature can only be interpreted considering all feature values together for a specific set of feature values.</p>"},{"location":"usage/#waterfall-plot","title":"Waterfall plot","text":"<p>The following figure shows an exemplary waterfall plot output for the MSA <code>example/example.py</code> and Pythia version 1.1.0.</p> <p>The x-axis depicts the difficulty and the y-axis the features alongside the respective feature value. The features are sorted by their Shapley value with the highest contribution on top. You can read the plot as follows. The base line difficulty that Pythia v1.1.0 learned is 0.35, as indicated by the <code>E[f(x)] = 0.35</code> on the x-axis. The <code>proportion_invariant</code> feature contributed to the overall prediction with a shift towards <code>1.0</code> (more difficult) of <code>0.01</code>, so in combination with the other features, a <code>proportion_invariant</code> of <code>0.341</code> indicates that the MSA is slightly more difficult than the average difficulty in the training set. We emphasize that the combination with the other features part, since the same value for <code>proportion_invariant</code> with a different MSA and different feature values for the remaining features might lead to a substantially different contribution to the overall prediction. The feature with the highest impact for this example is the patterns-over-taxa ratio (<code>num_patterns/num_taxa</code>). The overall contribution is 0.23 towards <code>0.0</code>, meaning it shifts the overall prediction towards <code>easy</code>.</p> <p></p>"},{"location":"usage/#more-details","title":"More Details","text":"<p>For further information please refer to this great book on interpretable ML, the documentation of the <code>shap</code> package, especially their notes on the interpretability of Shapley values.</p>"},{"location":"api/config/","title":"Config","text":""},{"location":"api/config/#pypythia.config.DEFAULT_MODEL_FILE","title":"<code>pypythia.config.DEFAULT_MODEL_FILE = pathlib.Path(__file__).parent / 'predictors/latest.txt'</code>  <code>module-attribute</code>","text":""},{"location":"api/config/#pypythia.config.DEFAULT_RAXMLNG_EXE","title":"<code>pypythia.config.DEFAULT_RAXMLNG_EXE = pathlib.Path(shutil.which('raxml-ng')) if shutil.which('raxml-ng') else None</code>  <code>module-attribute</code>","text":""},{"location":"api/custom_errors/","title":"Custom errors","text":""},{"location":"api/custom_errors/#pypythia.custom_errors.PyPythiaException","title":"<code>pypythia.custom_errors.PyPythiaException</code>","text":"<p>               Bases: <code>Exception</code></p> Source code in <code>pypythia/custom_errors.py</code> <pre><code>class PyPythiaException(Exception):\n    pass\n</code></pre>"},{"location":"api/custom_errors/#pypythia.custom_errors.RAxMLNGError","title":"<code>pypythia.custom_errors.RAxMLNGError</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Custom RAxML-NG Exception used when running RAxML-NG commands. In case of a subprocess.CalledProcessError, the output of this Exception is either the entire RAxML-NG output, or only the lines containing the cause for the RAxML-NG error if the RAxML-NG output contains lines starting with \"ERROR\"</p> Source code in <code>pypythia/custom_errors.py</code> <pre><code>class RAxMLNGError(Exception):\n    \"\"\"\n    Custom RAxML-NG Exception used when running RAxML-NG commands.\n    In case of a subprocess.CalledProcessError, the output of this Exception is either the entire RAxML-NG output,\n    or only the lines containing the cause for the RAxML-NG error if the RAxML-NG output contains\n    lines starting with \"ERROR\"\n    \"\"\"\n\n    def __init__(self, subprocess_exception: subprocess.CalledProcessError):\n        error_information = []\n\n        for line in subprocess_exception.output.split(\"\\n\"):\n            if line.strip().startswith(\"ERROR\"):\n                error_information.append(line.strip())\n\n        if len(error_information) &gt; 0:\n            error_details = \"RAxML-NG exited with the following error:\\n\"\n            error_details += \"\\t\" + \"\\n\\t\".join(error_information)\n        else:\n            error_details = \"check the following RAxML-NG log for further information on the error(s):\\n\"\n            error_details += subprocess_exception.output\n\n        cmd = \" \".join(subprocess_exception.cmd)\n        self.message = f\"Running RAxML-NG command failed: {cmd}\\n\" + error_details\n        super().__init__(self.message)\n</code></pre>"},{"location":"api/custom_types/","title":"Custom types","text":""},{"location":"api/custom_types/#pypythia.custom_types.DataType","title":"<code>pypythia.custom_types.DataType</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Data type for MSAs. - DNA = DNA data - AA = Protein data - MORPH = morphological data</p> Source code in <code>pypythia/custom_types.py</code> <pre><code>class DataType(Enum):\n    \"\"\"Data type for MSAs.\n    - DNA = DNA data\n    - AA = Protein data\n    - MORPH = morphological data\n    \"\"\"\n\n    DNA = \"DNA\"\n    AA = \"AA\"\n    MORPH = \"MORPH\"\n</code></pre>"},{"location":"api/custom_types/#pypythia.custom_types.FileFormat","title":"<code>pypythia.custom_types.FileFormat</code>","text":"<p>               Bases: <code>Enum</code></p> <p>File formats for MSAs - PHYLIP = phylip-relaxed - FASTA = fasta</p> Source code in <code>pypythia/custom_types.py</code> <pre><code>class FileFormat(Enum):\n    \"\"\"File formats for MSAs\n    - PHYLIP = phylip-relaxed\n    - FASTA = fasta\n    \"\"\"\n\n    PHYLIP = \"phylip-relaxed\"\n    FASTA = \"fasta\"\n</code></pre>"},{"location":"api/msa/","title":"Msa","text":""},{"location":"api/msa/#pypythia.msa.MSA","title":"<code>pypythia.msa.MSA</code>","text":"<p>Multiple Sequence Alignment class</p> <p>Parameters:</p> Name Type Description Default <code>taxa</code> <code>NDArray</code> <p>Array of taxa names</p> required <code>sequences</code> <code>NDArray</code> <p>The data matrix containing the sequence data. The order of the rows corresponds to the order of the taxa in the taxa array. The data is stored as a 2D numpy array of bytes using the S1 numpy data type.</p> required <code>data_type</code> <code>DataType</code> <p>Data type of the sequences</p> required <code>name</code> <code>str</code> <p>Name of the MSA</p> required <p>Attributes:</p> Name Type Description <code>taxa</code> <code>NDArray</code> <p>Array of taxa names</p> <code>sequences</code> <code>NDArray</code> <p>The data matrix containing the sequence data. The order of the rows corresponds to the order of the taxa in the taxa array. The data is stored as a 2D numpy array of bytes using the S1 numpy data type.</p> <code>data_type</code> <code>DataType</code> <p>Data type of the sequences</p> <code>name</code> <code>str</code> <p>Name of the MSA</p> <code>n_taxa</code> <code>int</code> <p>Number of taxa</p> <code>n_sites</code> <code>int</code> <p>Number of sites</p> <p>Raises:</p> Type Description <code>PyPythiaException</code> <p>If the number of taxa in <code>taxa</code> and the number of sequences in <code>sequences</code> do not match.</p> Source code in <code>pypythia/msa.py</code> <pre><code>class MSA:\n    \"\"\"Multiple Sequence Alignment class\n\n    Args:\n        taxa (npt.NDArray): Array of taxa names\n        sequences (npt.NDArray): The data matrix containing the sequence data.\n            The order of the rows corresponds to the order of the taxa in the taxa array.\n            The data is stored as a 2D numpy array of bytes using the S1 numpy data type.\n        data_type (DataType): Data type of the sequences\n        name (str): Name of the MSA\n\n    Attributes:\n        taxa (npt.NDArray): Array of taxa names\n        sequences (npt.NDArray): The data matrix containing the sequence data.\n            The order of the rows corresponds to the order of the taxa in the taxa array.\n            The data is stored as a 2D numpy array of bytes using the S1 numpy data type.\n        data_type (DataType): Data type of the sequences\n        name (str): Name of the MSA\n        n_taxa (int): Number of taxa\n        n_sites (int): Number of sites\n\n    Raises:\n        PyPythiaException: If the number of taxa in `taxa` and the number of sequences in `sequences` do not match.\n\n    \"\"\"\n\n    def __init__(\n        self, taxa: npt.NDArray, sequences: npt.NDArray, data_type: DataType, name: str\n    ):\n        if taxa.shape[0] != sequences.shape[0]:\n            raise PyPythiaException(\n                \"Number of taxa and sequences do not match: \"\n                f\"{taxa.shape[0]} != {sequences.shape[0]}.\"\n            )\n\n        self.taxa = taxa\n        self.sequences = sequences\n        self.data_type = data_type\n        self.name = name\n\n        self.n_taxa, self.n_sites = self.sequences.shape\n\n    def __str__(self):\n        return f\"MSA(name={self.name}, n_taxa={self.n_taxa}, n_sites={self.n_sites}, data_type={self.data_type})\"\n\n    def __repr__(self):\n        return str(self)\n\n    def contains_full_gap_sequences(self) -&gt; bool:\n        \"\"\"Check if the MSA contains full-gap sequences.\n\n        A full-gap sequence is a sequence where all sites are gaps so the sequence does not contain any information.\n\n        Returns:\n            True if full-gap sequences are present, False otherwise.\n        \"\"\"\n        return np.any(np.all(self.sequences == GAP, axis=1))\n\n    def contains_duplicate_sequences(self) -&gt; bool:\n        \"\"\"Check if the MSA contains duplicate sequences.\n\n        Returns:\n            True if duplicate sequences are present, False otherwise.\n        \"\"\"\n        unique_sequences = np.unique(self.sequences, axis=0)\n        return unique_sequences.shape[0] &lt; self.sequences.shape[0]\n\n    @property\n    def n_patterns(self) -&gt; int:\n        \"\"\"Returns the number of unique patterns in the MSA.\n\n        A pattern is a unique combination of characters at a site in the MSA.\n        A full-gap site is not considered a pattern.\n\n        Returns:\n            Number of unique patterns\n        \"\"\"\n        un = set([c.tobytes() for c in self.sequences.T])\n        return len(un) - ((GAP * self.n_taxa) in un)\n\n    @property\n    def proportion_gaps(self) -&gt; float:\n        \"\"\"Returns the proportion of gap characters in the MSA.\n        Note that prior to calculating the percentage, full-gap sites are removed.\n\n        Returns:\n            Proportion of gap characters in the MSA\n        \"\"\"\n        full_gap_sites_removed = self.sequences[\n            :, ~np.all(self.sequences.T == GAP, axis=1)\n        ]\n        return np.sum(full_gap_sites_removed == GAP) / full_gap_sites_removed.size\n\n    @property\n    def proportion_invariant(self) -&gt; float:\n        \"\"\"Returns the proportion of invariant sites in the MSA.\n        A site is considered invariant if all sequences have the same character at that site.\n        Full-gap sites are not counted as invariant.\n        A site is also counted as invariant, if there is a possible assignment of ambiguous characters such that the\n        site is invariant.\n        For example, the DNA site `AAAMA` is considered invariant because it can be resolved to `AAAAA`.\n\n        Returns:\n            Proportion of invariant sites in the MSA\n\n        \"\"\"\n        if self.data_type == DataType.DNA:\n            charmap = DNA_AMBIGUITY_MAP\n        elif self.data_type == DataType.AA:\n            charmap = AA_AMBIGUITY_MAP\n        else:\n            charmap = {}\n\n        non_gap_site_count = 0\n        invariant_count = 0\n\n        for site in self.sequences.T:\n            site = set(site.tobytes())\n            if site == {GAP_ORD}:\n                # full-gap sites are not counted as invariant\n                continue\n\n            non_gap_site_count += 1\n\n            for allowed in charmap.values():\n                if site.issubset(allowed):\n                    invariant_count += 1\n                    break\n\n        return invariant_count / non_gap_site_count\n\n    def entropy(self) -&gt; float:\n        \"\"\"Returns the entropy of the MSA.\n\n        The entropy is calculated as the mean entropy of all sites in the MSA.\n        and the site-entropy is calculated as the Shannon entropy of the site.\n\n        Returns:\n            Entropy of the MSA.\n        \"\"\"\n\n        def _site_entropy(site):\n            site_counter = Counter(site.tobytes())\n            site_counter.pop(GAP_ORD, None)\n\n            counts = np.array(list(site_counter.values()))\n            probabilities = counts / np.sum(counts)\n            return -np.sum(probabilities * np.log2(probabilities))\n\n        return np.mean([_site_entropy(site) for site in self.sequences.T])\n\n    def pattern_entropy(self) -&gt; float:\n        \"\"\"Returns an entropy-like metric based on the number of occurrences of all patterns of the MSA.\n\n        The pattern entropy is calculated as\n        $$\n        \\sum_{i=1}^{p} N_i \\log(N_i)\n        $$\n        with $N_i$ being the number of occurrences of pattern $i$ and $p$ being the number of unique patterns in the MSA.\n\n        Returns:\n            Entropy-like metric based on the number of occurrences of all patterns of the MSA.\n        \"\"\"\n        patterns = [c.tobytes() for c in self.sequences.T]\n        pattern_counter = Counter(patterns)\n        pattern_counts = np.array(list(pattern_counter.values()))\n        return np.sum(pattern_counts * np.log(pattern_counts))\n\n    def bollback_multinomial(self) -&gt; float:\n        \"\"\"\n        Returns the Bollback multinomial metric for the MSA.\n\n        The Bollback multinomial metric is calculated as\n        $$\n        \\sum_{i=1}^{p} N_i \\log(N_i) - n \\log(n)\n        $$\n        with $N_i$ being the number of occurrences of pattern $i$,\n        $p$ being the number of unique patterns in the MSA, and $n$ being the number of sites in the MSA.\n\n        Returns:\n            Bollback multinomial metric for the MSA.\n        \"\"\"\n        pattern_entropy = self.pattern_entropy()\n        return pattern_entropy - self.n_sites * math.log(self.n_sites)\n\n    def get_raxmlng_model(self) -&gt; str:\n        \"\"\"Returns a RAxML-NG model string based on the data type.\n\n        Returns the following models:\n            * For DNA data: GTR+G\n            * For Protein (AA) data: LG+G\n            * For morphological data: MULTIx_GTR where x refers to the maximum state value in the alignment\n\n        Returns:\n             RAxML-NG model string\n        \"\"\"\n        if self.data_type == DataType.DNA:\n            return \"GTR+G\"\n        elif self.data_type == DataType.AA:\n            return \"LG+G\"\n        elif self.data_type == DataType.MORPH:\n            unique = np.unique(self.sequences)\n            # the number of unique states is irrelevant for RAxML-NG, it only cares about the max state value...\n            num_states = int(max(unique)) + 1\n            return f\"MULTI{num_states}_GTR\"\n        else:\n            raise PyPythiaException(\"Unsupported data type: \", self.data_type)\n\n    def write(\n        self, output_file: pathlib.Path, file_format: FileFormat = FileFormat.PHYLIP\n    ):\n        \"\"\"Write the MSA to a file.\n\n        Args:\n            output_file (pathlib.Path): Path to the output file\n            file_format (FileFormat): File format to use for writing the MSA. Defaults to FileFormat.PHYLIP\n        \"\"\"\n        _biopython_sequences = [\n            SeqRecord(Seq(seq.tobytes()), id=taxon)\n            for seq, taxon in zip(self.sequences, self.taxa)\n        ]\n        SeqIO.write(_biopython_sequences, output_file, file_format.value)\n</code></pre>"},{"location":"api/msa/#pypythia.msa.MSA.n_patterns","title":"<code>n_patterns: int</code>  <code>property</code>","text":"<p>Returns the number of unique patterns in the MSA.</p> <p>A pattern is a unique combination of characters at a site in the MSA. A full-gap site is not considered a pattern.</p> <p>Returns:</p> Type Description <code>int</code> <p>Number of unique patterns</p>"},{"location":"api/msa/#pypythia.msa.MSA.proportion_gaps","title":"<code>proportion_gaps: float</code>  <code>property</code>","text":"<p>Returns the proportion of gap characters in the MSA. Note that prior to calculating the percentage, full-gap sites are removed.</p> <p>Returns:</p> Type Description <code>float</code> <p>Proportion of gap characters in the MSA</p>"},{"location":"api/msa/#pypythia.msa.MSA.proportion_invariant","title":"<code>proportion_invariant: float</code>  <code>property</code>","text":"<p>Returns the proportion of invariant sites in the MSA. A site is considered invariant if all sequences have the same character at that site. Full-gap sites are not counted as invariant. A site is also counted as invariant, if there is a possible assignment of ambiguous characters such that the site is invariant. For example, the DNA site <code>AAAMA</code> is considered invariant because it can be resolved to <code>AAAAA</code>.</p> <p>Returns:</p> Type Description <code>float</code> <p>Proportion of invariant sites in the MSA</p>"},{"location":"api/msa/#pypythia.msa.MSA.bollback_multinomial","title":"<code>bollback_multinomial()</code>","text":"<p>Returns the Bollback multinomial metric for the MSA.</p> <p>The Bollback multinomial metric is calculated as $$ \\sum_{i=1}^{p} N_i \\log(N_i) - n \\log(n) $$ with \\(N_i\\) being the number of occurrences of pattern \\(i\\), \\(p\\) being the number of unique patterns in the MSA, and \\(n\\) being the number of sites in the MSA.</p> <p>Returns:</p> Type Description <code>float</code> <p>Bollback multinomial metric for the MSA.</p> Source code in <code>pypythia/msa.py</code> <pre><code>def bollback_multinomial(self) -&gt; float:\n    \"\"\"\n    Returns the Bollback multinomial metric for the MSA.\n\n    The Bollback multinomial metric is calculated as\n    $$\n    \\sum_{i=1}^{p} N_i \\log(N_i) - n \\log(n)\n    $$\n    with $N_i$ being the number of occurrences of pattern $i$,\n    $p$ being the number of unique patterns in the MSA, and $n$ being the number of sites in the MSA.\n\n    Returns:\n        Bollback multinomial metric for the MSA.\n    \"\"\"\n    pattern_entropy = self.pattern_entropy()\n    return pattern_entropy - self.n_sites * math.log(self.n_sites)\n</code></pre>"},{"location":"api/msa/#pypythia.msa.MSA.contains_duplicate_sequences","title":"<code>contains_duplicate_sequences()</code>","text":"<p>Check if the MSA contains duplicate sequences.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if duplicate sequences are present, False otherwise.</p> Source code in <code>pypythia/msa.py</code> <pre><code>def contains_duplicate_sequences(self) -&gt; bool:\n    \"\"\"Check if the MSA contains duplicate sequences.\n\n    Returns:\n        True if duplicate sequences are present, False otherwise.\n    \"\"\"\n    unique_sequences = np.unique(self.sequences, axis=0)\n    return unique_sequences.shape[0] &lt; self.sequences.shape[0]\n</code></pre>"},{"location":"api/msa/#pypythia.msa.MSA.contains_full_gap_sequences","title":"<code>contains_full_gap_sequences()</code>","text":"<p>Check if the MSA contains full-gap sequences.</p> <p>A full-gap sequence is a sequence where all sites are gaps so the sequence does not contain any information.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if full-gap sequences are present, False otherwise.</p> Source code in <code>pypythia/msa.py</code> <pre><code>def contains_full_gap_sequences(self) -&gt; bool:\n    \"\"\"Check if the MSA contains full-gap sequences.\n\n    A full-gap sequence is a sequence where all sites are gaps so the sequence does not contain any information.\n\n    Returns:\n        True if full-gap sequences are present, False otherwise.\n    \"\"\"\n    return np.any(np.all(self.sequences == GAP, axis=1))\n</code></pre>"},{"location":"api/msa/#pypythia.msa.MSA.entropy","title":"<code>entropy()</code>","text":"<p>Returns the entropy of the MSA.</p> <p>The entropy is calculated as the mean entropy of all sites in the MSA. and the site-entropy is calculated as the Shannon entropy of the site.</p> <p>Returns:</p> Type Description <code>float</code> <p>Entropy of the MSA.</p> Source code in <code>pypythia/msa.py</code> <pre><code>def entropy(self) -&gt; float:\n    \"\"\"Returns the entropy of the MSA.\n\n    The entropy is calculated as the mean entropy of all sites in the MSA.\n    and the site-entropy is calculated as the Shannon entropy of the site.\n\n    Returns:\n        Entropy of the MSA.\n    \"\"\"\n\n    def _site_entropy(site):\n        site_counter = Counter(site.tobytes())\n        site_counter.pop(GAP_ORD, None)\n\n        counts = np.array(list(site_counter.values()))\n        probabilities = counts / np.sum(counts)\n        return -np.sum(probabilities * np.log2(probabilities))\n\n    return np.mean([_site_entropy(site) for site in self.sequences.T])\n</code></pre>"},{"location":"api/msa/#pypythia.msa.MSA.get_raxmlng_model","title":"<code>get_raxmlng_model()</code>","text":"<p>Returns a RAxML-NG model string based on the data type.</p> Returns the following models <ul> <li>For DNA data: GTR+G</li> <li>For Protein (AA) data: LG+G</li> <li>For morphological data: MULTIx_GTR where x refers to the maximum state value in the alignment</li> </ul> <p>Returns:</p> Type Description <code>str</code> <p>RAxML-NG model string</p> Source code in <code>pypythia/msa.py</code> <pre><code>def get_raxmlng_model(self) -&gt; str:\n    \"\"\"Returns a RAxML-NG model string based on the data type.\n\n    Returns the following models:\n        * For DNA data: GTR+G\n        * For Protein (AA) data: LG+G\n        * For morphological data: MULTIx_GTR where x refers to the maximum state value in the alignment\n\n    Returns:\n         RAxML-NG model string\n    \"\"\"\n    if self.data_type == DataType.DNA:\n        return \"GTR+G\"\n    elif self.data_type == DataType.AA:\n        return \"LG+G\"\n    elif self.data_type == DataType.MORPH:\n        unique = np.unique(self.sequences)\n        # the number of unique states is irrelevant for RAxML-NG, it only cares about the max state value...\n        num_states = int(max(unique)) + 1\n        return f\"MULTI{num_states}_GTR\"\n    else:\n        raise PyPythiaException(\"Unsupported data type: \", self.data_type)\n</code></pre>"},{"location":"api/msa/#pypythia.msa.MSA.pattern_entropy","title":"<code>pattern_entropy()</code>","text":"<p>Returns an entropy-like metric based on the number of occurrences of all patterns of the MSA.</p> <p>The pattern entropy is calculated as $$ \\sum_{i=1}^{p} N_i \\log(N_i) $$ with \\(N_i\\) being the number of occurrences of pattern \\(i\\) and \\(p\\) being the number of unique patterns in the MSA.</p> <p>Returns:</p> Type Description <code>float</code> <p>Entropy-like metric based on the number of occurrences of all patterns of the MSA.</p> Source code in <code>pypythia/msa.py</code> <pre><code>def pattern_entropy(self) -&gt; float:\n    \"\"\"Returns an entropy-like metric based on the number of occurrences of all patterns of the MSA.\n\n    The pattern entropy is calculated as\n    $$\n    \\sum_{i=1}^{p} N_i \\log(N_i)\n    $$\n    with $N_i$ being the number of occurrences of pattern $i$ and $p$ being the number of unique patterns in the MSA.\n\n    Returns:\n        Entropy-like metric based on the number of occurrences of all patterns of the MSA.\n    \"\"\"\n    patterns = [c.tobytes() for c in self.sequences.T]\n    pattern_counter = Counter(patterns)\n    pattern_counts = np.array(list(pattern_counter.values()))\n    return np.sum(pattern_counts * np.log(pattern_counts))\n</code></pre>"},{"location":"api/msa/#pypythia.msa.MSA.write","title":"<code>write(output_file, file_format=FileFormat.PHYLIP)</code>","text":"<p>Write the MSA to a file.</p> <p>Parameters:</p> Name Type Description Default <code>output_file</code> <code>Path</code> <p>Path to the output file</p> required <code>file_format</code> <code>FileFormat</code> <p>File format to use for writing the MSA. Defaults to FileFormat.PHYLIP</p> <code>PHYLIP</code> Source code in <code>pypythia/msa.py</code> <pre><code>def write(\n    self, output_file: pathlib.Path, file_format: FileFormat = FileFormat.PHYLIP\n):\n    \"\"\"Write the MSA to a file.\n\n    Args:\n        output_file (pathlib.Path): Path to the output file\n        file_format (FileFormat): File format to use for writing the MSA. Defaults to FileFormat.PHYLIP\n    \"\"\"\n    _biopython_sequences = [\n        SeqRecord(Seq(seq.tobytes()), id=taxon)\n        for seq, taxon in zip(self.sequences, self.taxa)\n    ]\n    SeqIO.write(_biopython_sequences, output_file, file_format.value)\n</code></pre>"},{"location":"api/msa/#pypythia.msa.parse","title":"<code>pypythia.msa.parse(msa_file, file_format=None, data_type=None)</code>","text":"<p>Parse a multiple sequence alignment file. Note that the file needs to be in FASTA or PHYLIP format.</p> <p>Note that per default, the file format and data type are inferred from the file content.</p> <p>If the file format cannot be determined, a PyPythiaException is raised. In this case, make sure the file is in proper FASTA or PHYLIP format. If you are absolutely sure it is, you can provide the file format manually.</p> <p>Similarly, if the data type cannot be inferred, a PyPythiaException is raised including information about the characters that could not be assigned to a data type. In this case, you can provide the data type manually. Note that we check for the data type in the following order: DNA -&gt; AA -&gt; MORPH. In case your MSA contains AA data, but coincidentally only contains characters that are nucleotides or ambiguous DNA characters, the data is assumed to be DNA. In this case, please provide the correct data type (<code>DataType.AA</code>) manually.</p> <p>Parameters:</p> Name Type Description Default <code>msa_file</code> <code>Path</code> <p>Path to the MSA file</p> required <code>file_format</code> <code>FileFormat</code> <p>File format of the MSA file. Defaults to None. In this case, the file format is determined automatically.</p> <code>None</code> <code>data_type</code> <code>DataType</code> <p>Data type of the sequences. Defaults to None. In this case, the data type is inferred from the sequences.</p> <code>None</code> <p>Returns:</p> Type Description <code>MSA</code> <p>The parsed MSA object.</p> Source code in <code>pypythia/msa.py</code> <pre><code>def parse(\n    msa_file: pathlib.Path,\n    file_format: Optional[FileFormat] = None,\n    data_type: Optional[DataType] = None,\n) -&gt; MSA:\n    \"\"\"Parse a multiple sequence alignment file. Note that the file needs to be in FASTA or PHYLIP format.\n\n    Note that per default, the file format and data type are inferred from the file content.\n\n    If the file format cannot be determined, a PyPythiaException is raised. In this case, make sure the file is in\n    proper FASTA or PHYLIP format. If you are absolutely sure it is, you can provide the file format manually.\n\n    Similarly, if the data type cannot be inferred, a PyPythiaException is raised including information about the\n    characters that could not be assigned to a data type. In this case, you can provide the data type manually.\n    Note that we check for the data type in the following order: DNA -&gt; AA -&gt; MORPH. In case your MSA contains AA data,\n    but coincidentally only contains characters that are nucleotides or ambiguous DNA characters, the data is assumed\n    to be DNA. In this case, please provide the correct data type (`DataType.AA`) manually.\n\n    Args:\n        msa_file (pathlib.Path): Path to the MSA file\n        file_format (FileFormat): File format of the MSA file. Defaults to None. In this case, the file format is determined automatically.\n        data_type (DataType): Data type of the sequences. Defaults to None. In this case, the data type is inferred from the sequences.\n\n    Returns:\n        The parsed MSA object.\n    \"\"\"\n    file_format = file_format or _get_file_format(msa_file)\n    msa_content = StringIO(msa_file.read_text().upper())\n    _msa = AlignIO.read(msa_content, format=file_format.value)\n    sequences = (\n        np.frombuffer(b\"\".join([rec.seq._data for rec in _msa]), dtype=\"S1\")\n        .reshape(len(_msa), -1)\n        .copy()\n    )\n    taxon_names = np.array([rec.id for rec in _msa])\n\n    if not data_type:\n        data_type = _guess_dtype(sequences)\n\n    char_mapping = {c: GAP for c in GAP_CHARS}\n    if data_type == DataType.DNA:\n        # replace all U characters with a T for convenience\n        char_mapping.update({b\"U\": b\"T\"})\n        char_mapping.update({c: GAP for c in DNA_GAP_CHARS})\n\n    for old_char, new_char in char_mapping.items():\n        sequences[sequences == old_char] = new_char\n\n    return MSA(taxon_names, sequences, data_type, msa_file.name)\n</code></pre>"},{"location":"api/msa/#pypythia.msa.remove_full_gap_sequences","title":"<code>pypythia.msa.remove_full_gap_sequences(msa, msa_name=None)</code>","text":"<p>Remove full-gap sequences from the MSA.</p> <p>A full-gap sequence is a sequence where all sites are gaps so the sequence does not contain any information.</p> <p>Parameters:</p> Name Type Description Default <code>msa</code> <code>MSA</code> <p>MSA object to remove full-gap sequences from</p> required <code>msa_name</code> <code>str</code> <p>Name of the new MSA. Defaults to None. In this case, the new MSA is named the same as the input MSA.</p> <code>None</code> <p>Returns:</p> Type Description <code>MSA</code> <p>MSA object without full-gap sequences.</p> <p>Raises:</p> Type Description <code>PyPythiaException</code> <p>If the MSA does not contain any full-gap sequences.</p> Source code in <code>pypythia/msa.py</code> <pre><code>def remove_full_gap_sequences(msa: MSA, msa_name: Optional[str] = None) -&gt; MSA:\n    \"\"\"Remove full-gap sequences from the MSA.\n\n    A full-gap sequence is a sequence where all sites are gaps so the sequence does not contain any information.\n\n    Args:\n        msa (MSA): MSA object to remove full-gap sequences from\n        msa_name (str): Name of the new MSA. Defaults to None. In this case, the new MSA is named the same as the input MSA.\n\n    Returns:\n        MSA object without full-gap sequences.\n\n    Raises:\n        PyPythiaException: If the MSA does not contain any full-gap sequences.\n    \"\"\"\n    if not msa.contains_full_gap_sequences():\n        raise PyPythiaException(\"No full-gap sequences found in MSA.\")\n\n    is_full_gap_sequence = np.all(msa.sequences == GAP, axis=1)\n    non_full_gap_sequences = msa.sequences[~is_full_gap_sequence]\n    non_full_gap_taxa = msa.taxa[~is_full_gap_sequence]\n\n    return MSA(\n        non_full_gap_taxa, non_full_gap_sequences, msa.data_type, msa_name or msa.name\n    )\n</code></pre>"},{"location":"api/msa/#pypythia.msa.deduplicate_sequences","title":"<code>pypythia.msa.deduplicate_sequences(msa, msa_name=None)</code>","text":"<p>Remove duplicate sequences from the MSA.</p> <p>Note that in case of duplicate sequences, the first occurrence (including the first taxon name) is kept and all subsequent occurrences are removed.</p> <p>Parameters:</p> Name Type Description Default <code>msa</code> <code>MSA</code> <p>MSA object to remove duplicate sequences from</p> required <code>msa_name</code> <code>str</code> <p>Name of the new MSA. Defaults to None. In this case, the new MSA is named the same as the input MSA.</p> <code>None</code> <p>Returns:</p> Type Description <code>MSA</code> <p>MSA object without duplicate sequences.</p> <p>Raises:</p> Type Description <code>PyPythiaException</code> <p>If the MSA does not contain any duplicate sequences.</p> Source code in <code>pypythia/msa.py</code> <pre><code>def deduplicate_sequences(msa: MSA, msa_name: Optional[str] = None) -&gt; MSA:\n    \"\"\"Remove duplicate sequences from the MSA.\n\n    Note that in case of duplicate sequences, the first occurrence (including the first taxon name) is kept\n    and all subsequent occurrences are removed.\n\n    Args:\n        msa (MSA): MSA object to remove duplicate sequences from\n        msa_name (str): Name of the new MSA. Defaults to None. In this case, the new MSA is named the same as the input MSA.\n\n    Returns:\n        MSA object without duplicate sequences.\n\n    Raises:\n        PyPythiaException: If the MSA does not contain any duplicate sequences.\n    \"\"\"\n    if not msa.contains_duplicate_sequences():\n        raise PyPythiaException(\"No duplicates found in MSA.\")\n\n    unique_sequences, unique_indices = np.unique(\n        msa.sequences, axis=0, return_index=True\n    )\n    unique_taxa = msa.taxa[unique_indices]\n\n    return MSA(unique_taxa, unique_sequences, msa.data_type, msa_name or msa.name)\n</code></pre>"},{"location":"api/prediction/","title":"Prediction","text":""},{"location":"api/prediction/#pypythia.prediction.predict_difficulty","title":"<code>pypythia.prediction.predict_difficulty(msa_file, model_file=DEFAULT_MODEL_FILE, raxmlng=DEFAULT_RAXMLNG_EXE, threads=None, seed=0, file_format=None, data_type=None, deduplicate=True, remove_full_gaps=True, reduced_msa_file=None)</code>","text":"<p>Predict the difficulty of an MSA using the PyPythia difficulty predictor.</p> <p>Per default, the MSA is deduplicated and full gap sequences are removed before the difficulty is predicted.</p> <p>Parameters:</p> Name Type Description Default <code>msa_file</code> <code>Path</code> <p>Path to the MSA file. Note that the MSA file must be in either FASTA or PHYLIP format.</p> required <code>model_file</code> <code>Path</code> <p>Path to the trained difficulty predictor model. Defaults to the latest model shipped with PyPythia.</p> <code>DEFAULT_MODEL_FILE</code> <code>raxmlng</code> <code>Path</code> <p>Path to the RAxML-NG executable. If not set, uses the RAxML-NG binary found in the PATH environment variable.</p> <code>DEFAULT_RAXMLNG_EXE</code> <code>threads</code> <code>int</code> <p>Number of threads to use for parallel parsimony tree inference. If not set, uses the RAxML-NG auto parallelization scheme.</p> <code>None</code> <code>seed</code> <code>int</code> <p>Random seed to use for the parsimony tree inference. Defaults to 0.</p> <code>0</code> <code>file_format</code> <code>FileFormat</code> <p>File format of the MSA file. Defaults to None. In this case, the file format is inferred based on the file content. See <code>pypythia.msa.parse</code> for information on when this is required.</p> <code>None</code> <code>data_type</code> <code>DataType</code> <p>Data type of the MSA sequences. Defaults to None. In this case, the data type is inferred based on the file content. See <code>pypythia.msa.parse</code> for information on when this is required.</p> <code>None</code> <code>deduplicate</code> <code>bool</code> <p>If True, remove duplicate sequences from the MSA. Defaults to True.</p> <code>True</code> <code>remove_full_gaps</code> <code>bool</code> <p>If True, remove full gap sequences from the MSA. Defaults to True.</p> <code>True</code> <code>reduced_msa_file</code> <code>Path</code> <p>Path to store the reduced MSA after deduplication and removal of full gap sequences.</p> <code>None</code> <p>Returns:</p> Type Description <code>float64</code> <p>np.float64: Predicted difficulty of the MSA.</p> Source code in <code>pypythia/prediction.py</code> <pre><code>def predict_difficulty(\n    msa_file: pathlib.Path,\n    model_file: Optional[pathlib.Path] = DEFAULT_MODEL_FILE,\n    raxmlng: Optional[pathlib.Path] = DEFAULT_RAXMLNG_EXE,\n    threads: int = None,\n    seed: int = 0,\n    file_format: Optional[FileFormat] = None,\n    data_type: Optional[DataType] = None,\n    deduplicate: bool = True,\n    remove_full_gaps: bool = True,\n    reduced_msa_file: Optional[pathlib.Path] = None,\n) -&gt; np.float64:\n    \"\"\"Predict the difficulty of an MSA using the PyPythia difficulty predictor.\n\n    Per default, the MSA is deduplicated and full gap sequences are removed before the difficulty is predicted.\n\n    Args:\n        msa_file (pathlib.Path): Path to the MSA file. Note that the MSA file must be in either FASTA or PHYLIP format.\n        model_file (pathlib.Path, optional): Path to the trained difficulty predictor model.\n            Defaults to the latest model shipped with PyPythia.\n        raxmlng (pathlib.Path, optional): Path to the RAxML-NG executable.\n            If not set, uses the RAxML-NG binary found in the PATH environment variable.\n        threads (int, optional): Number of threads to use for parallel parsimony tree inference. If not set, uses the\n            RAxML-NG auto parallelization scheme.\n        seed (int, optional): Random seed to use for the parsimony tree inference. Defaults to 0.\n        file_format (FileFormat, optional): File format of the MSA file. Defaults to None. In this case, the file format\n            is inferred based on the file content. See `pypythia.msa.parse` for information on when this is required.\n        data_type (DataType, optional): Data type of the MSA sequences. Defaults to None. In this case, the data type\n            is inferred based on the file content. See `pypythia.msa.parse` for information on when this is required.\n        deduplicate (bool, optional): If True, remove duplicate sequences from the MSA. Defaults to True.\n        remove_full_gaps (bool, optional): If True, remove full gap sequences from the MSA. Defaults to True.\n        reduced_msa_file (pathlib.Path, optional): Path to store the reduced MSA after deduplication and removal of full gap sequences.\n\n    Returns:\n        np.float64: Predicted difficulty of the MSA.\n    \"\"\"\n\n    predictor = DifficultyPredictor(model_file=model_file)\n\n    if raxmlng is None:\n        raise PyPythiaException(\n            \"Path to the RAxML-NG executable is required if 'raxml-ng' is not in $PATH.\"\n        )\n\n    raxmlng = RAxMLNG(**{\"exe_path\": raxmlng} if raxmlng else {})\n    msa = parse(msa_file, file_format=file_format, data_type=data_type)\n\n    if deduplicate and msa.contains_duplicate_sequences():\n        msa = deduplicate_sequences(msa)\n    if remove_full_gaps and msa.contains_full_gap_sequences():\n        msa = remove_full_gap_sequences(msa)\n\n    if reduced_msa_file:\n        msa.write(reduced_msa_file)\n\n    msa_features = collect_features(\n        msa, msa_file, raxmlng, log_info=False, threads=threads, seed=seed\n    )\n    difficulty = predictor.predict(msa_features)\n\n    return difficulty[0]\n</code></pre>"},{"location":"api/prediction/#pypythia.prediction.collect_features","title":"<code>pypythia.prediction.collect_features(msa, msa_file, raxmlng, pars_trees_file=None, log_info=True, threads=None, seed=0)</code>","text":"<p>Helper function to collect all features required for predicting the difficulty of the MSA.</p> <p>Parameters:</p> Name Type Description Default <code>msa</code> <code>MSA</code> <p>MSA object corresponding to the MSA file to compute the features for.</p> required <code>raxmlng</code> <code>RAxMLNG</code> <p>Initialized RAxMLNG object.</p> required <code>pars_trees_file</code> <code>Path</code> <p>Path to store the inferred parsimony trees. Defaults to None. In this case, the trees are not stored.</p> <code>None</code> <code>log_info</code> <code>bool</code> <p>If True, log intermediate progress information using the default logger.</p> <code>True</code> <code>threads</code> <code>int</code> <p>The number of threads to use for parallel parsimony tree inference. Defaults to None. Uses the RAxML-NG auto parallelization scheme if none is set.</p> <code>None</code> <code>seed</code> <code>int</code> <p>Random seed to use for the parsimony tree inference. Defaults to 0.</p> <code>0</code> <p>Returns:     Dataframe containing a single row with all features required for predicting the difficulty of the MSA.     The columns correspond to the feature names the predictor was trained with.</p> Source code in <code>pypythia/prediction.py</code> <pre><code>def collect_features(\n    msa: MSA,\n    msa_file: pathlib.Path,\n    raxmlng: RAxMLNG,\n    pars_trees_file: Optional[pathlib.Path] = None,\n    log_info: bool = True,\n    threads: int = None,\n    seed: int = 0,\n) -&gt; pd.DataFrame:\n    \"\"\"Helper function to collect all features required for predicting the difficulty of the MSA.\n\n    Args:\n        msa (MSA): MSA object corresponding to the MSA file to compute the features for.\n        raxmlng (RAxMLNG): Initialized RAxMLNG object.\n        pars_trees_file (pathlib.Path, optional): Path to store the inferred parsimony trees. Defaults to None.\n            In this case, the trees are not stored.\n        log_info (bool, optional): If True, log intermediate progress information using the default logger.\n        threads (int, optional): The number of threads to use for parallel parsimony tree inference. Defaults to None.\n            Uses the RAxML-NG auto parallelization scheme if none is set.\n        seed (int, optional): Random seed to use for the parsimony tree inference. Defaults to 0.\n    Returns:\n        Dataframe containing a single row with all features required for predicting the difficulty of the MSA.\n        The columns correspond to the feature names the predictor was trained with.\n    \"\"\"\n    if not log_info:\n        logger.remove()\n\n    with TemporaryDirectory() as tmpdir:\n        msa_file = msa_file\n        model = msa.get_raxmlng_model()\n\n        log_runtime_information(\"Retrieving num_taxa, num_sites.\", log_runtime=True)\n\n        n_pars_trees = 24\n        log_runtime_information(\n            f\"Inferring {n_pars_trees} parsimony trees with random seed {seed}.\",\n            log_runtime=True,\n        )\n        trees = raxmlng.infer_parsimony_trees(\n            msa_file,\n            model,\n            pathlib.Path(tmpdir) / \"pars\",\n            redo=None,\n            seed=seed,\n            n_trees=n_pars_trees,\n            **dict(threads=threads) if threads else {},\n        )\n        if pars_trees_file is not None:\n            log_runtime_information(\n                f\"Storing the inferred parsimony trees in the file {pars_trees_file}.\"\n            )\n            shutil.copy(trees, pars_trees_file)\n\n        log_runtime_information(\n            \"Computing the RF-Distance for the parsimony trees.\", log_runtime=True\n        )\n        num_topos, rel_rfdist, _ = raxmlng.get_rfdistance_results(trees, redo=None)\n\n        features = {\n            \"num_taxa\": msa.n_taxa,\n            \"num_sites\": msa.n_sites,\n            \"num_patterns\": msa.n_patterns,\n            \"num_patterns/num_taxa\": msa.n_patterns / msa.n_taxa,\n            \"num_sites/num_taxa\": msa.n_sites / msa.n_taxa,\n            \"num_patterns/num_sites\": msa.n_patterns / msa.n_sites,\n            \"proportion_gaps\": msa.proportion_gaps,\n            \"proportion_invariant\": msa.proportion_invariant,\n            \"entropy\": msa.entropy(),\n            \"bollback\": msa.bollback_multinomial(),\n            \"pattern_entropy\": msa.pattern_entropy(),\n            \"avg_rfdist_parsimony\": rel_rfdist,\n            \"proportion_unique_topos_parsimony\": num_topos / n_pars_trees,\n        }\n        return pd.DataFrame(features, index=[0])\n</code></pre>"},{"location":"api/predictor/","title":"Predictor","text":""},{"location":"api/predictor/#pypythia.predictor.DifficultyPredictor","title":"<code>pypythia.predictor.DifficultyPredictor</code>","text":"<p>Class structure for the trained difficulty predictor.</p> <p>This class provides methods for predicting the difficulty and plot the shapley values for an MSA.</p> <p>Parameters:</p> Name Type Description Default <code>model_file</code> <code>Path</code> <p>Path to the trained difficulty predictor model. Defaults to the latest model shipped with PyPythia. Note that this model file must be in the LightGBM .txt format.</p> <code>DEFAULT_MODEL_FILE</code> <code>features</code> <code>list[str]</code> <p>Names of the features the predictor was trained with. Defaults to None. In this case, the features are inferred from the model file.</p> <code>None</code> <p>Attributes:</p> Name Type Description <code>predictor</code> <p>Loaded trained predictor.</p> <code>features</code> <p>Names of the features the predictor was trained with.</p> Source code in <code>pypythia/predictor.py</code> <pre><code>class DifficultyPredictor:\n    \"\"\"Class structure for the trained difficulty predictor.\n\n    This class provides methods for predicting the difficulty and plot the shapley values for an MSA.\n\n    Args:\n        model_file (pathlib.Path, optional): Path to the trained difficulty predictor model.\n            Defaults to the latest model shipped with PyPythia.\n            Note that this model file must be in the LightGBM .txt format.\n        features (list[str], optional): Names of the features the predictor was trained with.\n            Defaults to None. In this case, the features are inferred from the model file.\n\n    Attributes:\n        predictor: Loaded trained predictor.\n        features: Names of the features the predictor was trained with.\n    \"\"\"\n\n    def __init__(\n        self,\n        model_file: Optional[pathlib.Path] = DEFAULT_MODEL_FILE,\n        features: list[str] = None,\n    ) -&gt; None:\n        self.model_file = model_file\n        self.predictor = lgb.Booster(model_file=model_file)\n        self.features = self.predictor.feature_name() if features is None else features\n\n    def __str__(self):\n        return f\"DifficultyPredictor(model_file={self.model_file}, features={self.features})\"\n\n    def __repr__(self):\n        return self.__str__()\n\n    def _check_query(self, query: pd.DataFrame):\n        if not set(self.features).issubset(query.columns):\n            missing_features = set(self.features) - set(query.columns)\n            raise PyPythiaException(\n                \"The provided query does not contain all features the predictor was trained with. \"\n                \"Missing features: \" + \", \".join(missing_features)\n            )\n\n    def predict(self, query: pd.DataFrame) -&gt; npt.NDArray[np.float64]:\n        \"\"\"Predict the difficulty for a set of MSAs defined by rows in the given query dataframe.\n\n        Args:\n            query (pd.DataFrame): DataFrame containing the features for which to predict the difficulty.\n                Each row in the DataFrame corresponds to a single MSA and the columns correspond to the features.\n\n        Returns:\n            A numpy array of predicted difficulties for the provided set of MSAs in float64 format.\n            The difficulties are values in the range [0, 1] where higher values indicate higher difficulty.\n\n        \"\"\"\n        self._check_query(query)\n\n        try:\n            prediction = self.predictor.predict(query[self.features])\n            prediction = prediction.clip(min=0.0, max=1.0)\n            return prediction\n        except Exception as e:\n            raise PyPythiaException(\n                \"An error occurred predicting the difficulty for the provided set of MSA features.\"\n            ) from e\n\n    def plot_shapley_values(self, query: pd.DataFrame) -&gt; Figure:\n        \"\"\"Plot the shapley values for the **first** MSA in the given query dataframe.\n\n        Please read our notes on SHAP values in the documentation to understand the plot.\n\n        Args:\n            query (pd.DataFrame): DataFrame containing the features for which to plot the shapley values.\n\n        Returns:\n            A matplotlib Figure object containing the waterfall plot of the shapley values for the first MSA in the query.\n        \"\"\"\n        with warnings.catch_warnings():\n            warnings.simplefilter(\"ignore\")\n            import shap\n\n        self._check_query(query)\n\n        df = query[self.features]\n\n        explainer = shap.TreeExplainer(self.predictor)\n        shap_values = explainer.shap_values(df)\n        base_values = explainer.expected_value\n\n        return shap.plots.waterfall(\n            shap.Explanation(\n                values=shap_values[0], base_values=base_values, data=df.iloc[0]\n            ),\n            show=False,\n        ).figure\n</code></pre>"},{"location":"api/predictor/#pypythia.predictor.DifficultyPredictor.plot_shapley_values","title":"<code>plot_shapley_values(query)</code>","text":"<p>Plot the shapley values for the first MSA in the given query dataframe.</p> <p>Please read our notes on SHAP values in the documentation to understand the plot.</p> <p>Parameters:</p> Name Type Description Default <code>query</code> <code>DataFrame</code> <p>DataFrame containing the features for which to plot the shapley values.</p> required <p>Returns:</p> Type Description <code>Figure</code> <p>A matplotlib Figure object containing the waterfall plot of the shapley values for the first MSA in the query.</p> Source code in <code>pypythia/predictor.py</code> <pre><code>def plot_shapley_values(self, query: pd.DataFrame) -&gt; Figure:\n    \"\"\"Plot the shapley values for the **first** MSA in the given query dataframe.\n\n    Please read our notes on SHAP values in the documentation to understand the plot.\n\n    Args:\n        query (pd.DataFrame): DataFrame containing the features for which to plot the shapley values.\n\n    Returns:\n        A matplotlib Figure object containing the waterfall plot of the shapley values for the first MSA in the query.\n    \"\"\"\n    with warnings.catch_warnings():\n        warnings.simplefilter(\"ignore\")\n        import shap\n\n    self._check_query(query)\n\n    df = query[self.features]\n\n    explainer = shap.TreeExplainer(self.predictor)\n    shap_values = explainer.shap_values(df)\n    base_values = explainer.expected_value\n\n    return shap.plots.waterfall(\n        shap.Explanation(\n            values=shap_values[0], base_values=base_values, data=df.iloc[0]\n        ),\n        show=False,\n    ).figure\n</code></pre>"},{"location":"api/predictor/#pypythia.predictor.DifficultyPredictor.predict","title":"<code>predict(query)</code>","text":"<p>Predict the difficulty for a set of MSAs defined by rows in the given query dataframe.</p> <p>Parameters:</p> Name Type Description Default <code>query</code> <code>DataFrame</code> <p>DataFrame containing the features for which to predict the difficulty. Each row in the DataFrame corresponds to a single MSA and the columns correspond to the features.</p> required <p>Returns:</p> Type Description <code>NDArray[float64]</code> <p>A numpy array of predicted difficulties for the provided set of MSAs in float64 format.</p> <code>NDArray[float64]</code> <p>The difficulties are values in the range [0, 1] where higher values indicate higher difficulty.</p> Source code in <code>pypythia/predictor.py</code> <pre><code>def predict(self, query: pd.DataFrame) -&gt; npt.NDArray[np.float64]:\n    \"\"\"Predict the difficulty for a set of MSAs defined by rows in the given query dataframe.\n\n    Args:\n        query (pd.DataFrame): DataFrame containing the features for which to predict the difficulty.\n            Each row in the DataFrame corresponds to a single MSA and the columns correspond to the features.\n\n    Returns:\n        A numpy array of predicted difficulties for the provided set of MSAs in float64 format.\n        The difficulties are values in the range [0, 1] where higher values indicate higher difficulty.\n\n    \"\"\"\n    self._check_query(query)\n\n    try:\n        prediction = self.predictor.predict(query[self.features])\n        prediction = prediction.clip(min=0.0, max=1.0)\n        return prediction\n    except Exception as e:\n        raise PyPythiaException(\n            \"An error occurred predicting the difficulty for the provided set of MSA features.\"\n        ) from e\n</code></pre>"},{"location":"api/raxmlng/","title":"Raxmlng","text":""},{"location":"api/raxmlng/#pypythia.raxmlng.RAxMLNG","title":"<code>pypythia.raxmlng.RAxMLNG</code>","text":"<p>Class to interact with the RAxML-NG binary.</p> <p>Parameters:</p> Name Type Description Default <code>exe_path</code> <code>Path</code> <p>Path to the RAxML-NG executable. Defaults to the binary found in the PATH environment variable.</p> <code>DEFAULT_RAXMLNG_EXE</code> <p>Attributes:</p> Name Type Description <code>exe_path</code> <code>Path</code> <p>Path to the RAxML-NG executable.</p> Source code in <code>pypythia/raxmlng.py</code> <pre><code>class RAxMLNG:\n    \"\"\"Class to interact with the RAxML-NG binary.\n\n    Args:\n        exe_path (pathlib.Path, optional): Path to the RAxML-NG executable. Defaults to the binary found in the PATH environment variable.\n\n    Attributes:\n        exe_path (pathlib.Path): Path to the RAxML-NG executable.\n    \"\"\"\n\n    def __init__(self, exe_path: Optional[pathlib.Path] = DEFAULT_RAXMLNG_EXE):\n        self.exe_path = exe_path\n\n    def _base_cmd(\n        self, msa_file: pathlib.Path, model: str, prefix: pathlib.Path, **kwargs\n    ) -&gt; list[str]:\n        additional_settings = []\n        for key, value in kwargs.items():\n            if value is None:\n                additional_settings += [f\"--{key}\"]\n            else:\n                additional_settings += [f\"--{key}\", str(value)]\n\n        return [\n            str(self.exe_path.absolute()),\n            \"--msa\",\n            str(msa_file.absolute()),\n            \"--model\",\n            model,\n            \"--prefix\",\n            str(prefix.absolute()),\n            *additional_settings,\n        ]\n\n    def _run_alignment_parse(\n        self, msa_file: pathlib.Path, model: str, prefix: pathlib.Path, **kwargs\n    ) -&gt; None:\n        cmd = self._base_cmd(msa_file, model, prefix, parse=None, **kwargs)\n        run_raxmlng_command(cmd)\n\n    def _run_rfdist(\n        self, trees_file: pathlib.Path, prefix: pathlib.Path, **kwargs\n    ) -&gt; None:\n        additional_settings = []\n        for key, value in kwargs.items():\n            if value is None:\n                additional_settings += [f\"--{key}\"]\n            else:\n                additional_settings += [f\"--{key}\", str(value)]\n        cmd = [\n            str(self.exe_path.absolute()),\n            \"--rfdist\",\n            str(trees_file.absolute()),\n            \"--prefix\",\n            str(prefix.absolute()),\n            *additional_settings,\n        ]\n        run_raxmlng_command(cmd)\n\n    def infer_parsimony_trees(\n        self,\n        msa_file: pathlib.Path,\n        model: str,\n        prefix: pathlib.Path,\n        n_trees: int = 24,\n        **kwargs,\n    ) -&gt; pathlib.Path:\n        \"\"\"Method that infers n_trees using the RAxML-NG implementation of maximum parsimony.\n\n        Args:\n            msa_file (pathlib.Path): Filepath pointing to the MSA file.\n            model (str): String representation of the substitution model to use. Needs to be a valid RAxML-NG model.\n                For example \"GTR+G\" for DNA data or \"LG+G\" for protein data.\n            prefix (pathlib.Path): Prefix to use when running RAxML-NG.\n            n_trees (int): Number of trees to infer. Defaults to 24.\n            **kwargs: Additional arguments to pass to the RAxML-NG command.\n                The name of the kwarg needs to be a valid RAxML-NG flag.\n                For flags with a value pass it like this: \"flag=value\", for flags without a value pass it like this: \"flag=None\".\n                See https://github.com/amkozlov/raxml-ng for all options.\n\n        Returns:\n            Filepath pointing to the inferred maximum parsimony trees.\n        \"\"\"\n        cmd = self._base_cmd(\n            msa_file, model, prefix, start=None, tree=f\"pars{{{n_trees}}}\", **kwargs\n        )\n        run_raxmlng_command(cmd)\n        return pathlib.Path(f\"{prefix}.raxml.startTree\")\n\n    def get_rfdistance_results(\n        self, trees_file: pathlib.Path, prefix: pathlib.Path = None, **kwargs\n    ) -&gt; tuple[float, float, float]:\n        \"\"\"Method that computes the number of unique topologies, relative RF-Distance, and absolute RF-Distance for the given set of trees.\n\n        Args:\n            trees_file (pathlib.Path): Filepath pointing to the file containing the trees.\n            prefix (pathlib.Path, optional): Prefix to use when running RAxML-NG. Defaults to None. If None, a temporary directory is used.\n            **kwargs: Additional arguments to pass to the RAxML-NG command.\n                The name of the kwarg needs to be a valid RAxML-NG flag.\n                For flags with a value pass it like this: \"flag=value\", for flags without a value pass it like this: \"flag=None\".\n                See\n\n        Returns:\n            num_topos (float): Number of unique topologies of the given set of trees.\n            rel_rfdist (float): Relative RF-Distance of the given set of trees. Computed as average over all pairwise RF-Distances. Value between 0.0 and 1.0.\n            abs_rfdist (float): Absolute RF-Distance of the given set of trees.\n        \"\"\"\n        with TemporaryDirectory() as tmpdir:\n            tmpdir = pathlib.Path(tmpdir)\n            if not prefix:\n                prefix = tmpdir / \"rfdist\"\n            self._run_rfdist(trees_file, prefix, **kwargs)\n            log_file = pathlib.Path(f\"{prefix}.raxml.log\")\n            return _get_raxmlng_rfdist_results(log_file)\n</code></pre>"},{"location":"api/raxmlng/#pypythia.raxmlng.RAxMLNG.get_rfdistance_results","title":"<code>get_rfdistance_results(trees_file, prefix=None, **kwargs)</code>","text":"<p>Method that computes the number of unique topologies, relative RF-Distance, and absolute RF-Distance for the given set of trees.</p> <p>Parameters:</p> Name Type Description Default <code>trees_file</code> <code>Path</code> <p>Filepath pointing to the file containing the trees.</p> required <code>prefix</code> <code>Path</code> <p>Prefix to use when running RAxML-NG. Defaults to None. If None, a temporary directory is used.</p> <code>None</code> <code>**kwargs</code> <p>Additional arguments to pass to the RAxML-NG command. The name of the kwarg needs to be a valid RAxML-NG flag. For flags with a value pass it like this: \"flag=value\", for flags without a value pass it like this: \"flag=None\". See</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>num_topos</code> <code>float</code> <p>Number of unique topologies of the given set of trees.</p> <code>rel_rfdist</code> <code>float</code> <p>Relative RF-Distance of the given set of trees. Computed as average over all pairwise RF-Distances. Value between 0.0 and 1.0.</p> <code>abs_rfdist</code> <code>float</code> <p>Absolute RF-Distance of the given set of trees.</p> Source code in <code>pypythia/raxmlng.py</code> <pre><code>def get_rfdistance_results(\n    self, trees_file: pathlib.Path, prefix: pathlib.Path = None, **kwargs\n) -&gt; tuple[float, float, float]:\n    \"\"\"Method that computes the number of unique topologies, relative RF-Distance, and absolute RF-Distance for the given set of trees.\n\n    Args:\n        trees_file (pathlib.Path): Filepath pointing to the file containing the trees.\n        prefix (pathlib.Path, optional): Prefix to use when running RAxML-NG. Defaults to None. If None, a temporary directory is used.\n        **kwargs: Additional arguments to pass to the RAxML-NG command.\n            The name of the kwarg needs to be a valid RAxML-NG flag.\n            For flags with a value pass it like this: \"flag=value\", for flags without a value pass it like this: \"flag=None\".\n            See\n\n    Returns:\n        num_topos (float): Number of unique topologies of the given set of trees.\n        rel_rfdist (float): Relative RF-Distance of the given set of trees. Computed as average over all pairwise RF-Distances. Value between 0.0 and 1.0.\n        abs_rfdist (float): Absolute RF-Distance of the given set of trees.\n    \"\"\"\n    with TemporaryDirectory() as tmpdir:\n        tmpdir = pathlib.Path(tmpdir)\n        if not prefix:\n            prefix = tmpdir / \"rfdist\"\n        self._run_rfdist(trees_file, prefix, **kwargs)\n        log_file = pathlib.Path(f\"{prefix}.raxml.log\")\n        return _get_raxmlng_rfdist_results(log_file)\n</code></pre>"},{"location":"api/raxmlng/#pypythia.raxmlng.RAxMLNG.infer_parsimony_trees","title":"<code>infer_parsimony_trees(msa_file, model, prefix, n_trees=24, **kwargs)</code>","text":"<p>Method that infers n_trees using the RAxML-NG implementation of maximum parsimony.</p> <p>Parameters:</p> Name Type Description Default <code>msa_file</code> <code>Path</code> <p>Filepath pointing to the MSA file.</p> required <code>model</code> <code>str</code> <p>String representation of the substitution model to use. Needs to be a valid RAxML-NG model. For example \"GTR+G\" for DNA data or \"LG+G\" for protein data.</p> required <code>prefix</code> <code>Path</code> <p>Prefix to use when running RAxML-NG.</p> required <code>n_trees</code> <code>int</code> <p>Number of trees to infer. Defaults to 24.</p> <code>24</code> <code>**kwargs</code> <p>Additional arguments to pass to the RAxML-NG command. The name of the kwarg needs to be a valid RAxML-NG flag. For flags with a value pass it like this: \"flag=value\", for flags without a value pass it like this: \"flag=None\". See https://github.com/amkozlov/raxml-ng for all options.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Path</code> <p>Filepath pointing to the inferred maximum parsimony trees.</p> Source code in <code>pypythia/raxmlng.py</code> <pre><code>def infer_parsimony_trees(\n    self,\n    msa_file: pathlib.Path,\n    model: str,\n    prefix: pathlib.Path,\n    n_trees: int = 24,\n    **kwargs,\n) -&gt; pathlib.Path:\n    \"\"\"Method that infers n_trees using the RAxML-NG implementation of maximum parsimony.\n\n    Args:\n        msa_file (pathlib.Path): Filepath pointing to the MSA file.\n        model (str): String representation of the substitution model to use. Needs to be a valid RAxML-NG model.\n            For example \"GTR+G\" for DNA data or \"LG+G\" for protein data.\n        prefix (pathlib.Path): Prefix to use when running RAxML-NG.\n        n_trees (int): Number of trees to infer. Defaults to 24.\n        **kwargs: Additional arguments to pass to the RAxML-NG command.\n            The name of the kwarg needs to be a valid RAxML-NG flag.\n            For flags with a value pass it like this: \"flag=value\", for flags without a value pass it like this: \"flag=None\".\n            See https://github.com/amkozlov/raxml-ng for all options.\n\n    Returns:\n        Filepath pointing to the inferred maximum parsimony trees.\n    \"\"\"\n    cmd = self._base_cmd(\n        msa_file, model, prefix, start=None, tree=f\"pars{{{n_trees}}}\", **kwargs\n    )\n    run_raxmlng_command(cmd)\n    return pathlib.Path(f\"{prefix}.raxml.startTree\")\n</code></pre>"},{"location":"api/raxmlng/#pypythia.raxmlng.run_raxmlng_command","title":"<code>pypythia.raxmlng.run_raxmlng_command(cmd)</code>","text":"<p>Helper method to run a RAxML-NG command.</p> <p>Parameters:</p> Name Type Description Default <code>cmd</code> <code>list</code> <p>List of strings representing the RAxML-NG command to run.</p> required <p>Raises:</p> Type Description <code>RAxMLNGError</code> <p>If the RAxML-NG command fails with a CalledProcessError.</p> <code>RuntimeError</code> <p>If the RAxML-NG command fails with any other error.</p> Source code in <code>pypythia/raxmlng.py</code> <pre><code>def run_raxmlng_command(cmd: list[str]) -&gt; None:\n    \"\"\"Helper method to run a RAxML-NG command.\n\n    Args:\n        cmd (list): List of strings representing the RAxML-NG command to run.\n\n    Raises:\n        RAxMLNGError: If the RAxML-NG command fails with a CalledProcessError.\n        RuntimeError: If the RAxML-NG command fails with any other error.\n    \"\"\"\n    try:\n        subprocess.check_output(cmd, encoding=\"utf-8\")\n    except subprocess.CalledProcessError as e:\n        raise RAxMLNGError(subprocess_exception=e)\n    except Exception as e:\n        raise RuntimeError(\"Running RAxML-NG command failed.\") from e\n</code></pre>"}]}